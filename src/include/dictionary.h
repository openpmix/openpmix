/*
 * This file is autogenerated by construct_dictionary.py.
 * Do not edit this file by hand.
 */

#include "src/include/pmix_config.h"
#include "src/include/pmix_globals.h"

pmix_regattr_input_t dictionary[] = {
    {.name = "PMIX_ATTR_UNDEF", .string = "pmix.undef", .type = PMIX_POINTER,
     .description = (char *[]){"NONE"}},

    {.name = "PMIX_EVENT_BASE", .string = "pmix.evbase", .type = PMIX_POINTER,
     .description = (char *[]){"(void*) Pointer to an event_base to use in place of",
                               "the internal progress thread. All \ac{PMIx} library",
                               "events are to be assigned to the provided event base.",
                               "The event base must be compatible with the event",
                               "library used by the PMIx implementation - e.g.,",
                               "either both the host and PMIx library must use",
                               "libevent, or both must use libev. Cross-matches are",
                               "unlikely to work and should be avoided - it is the",
                               "responsibility of the host to ensure that the PMIx",
                               "implementation supports (and was built with) the",
                               "appropriate event library.", NULL}},

    {.name = "PMIX_EXTERNAL_PROGRESS", .string = "pmix.evext", .type = PMIX_BOOL,
     .description = (char *[]){"The host shall progress the PMIx library via calls to",
                               "PMIx_Progress", NULL}},

    {.name = "PMIX_SERVER_TOOL_SUPPORT", .string = "pmix.srvr.tool", .type = PMIX_BOOL,
     .description = (char *[]){"The host RM wants to declare itself as willing to",
                               "accept tool connection requests", NULL}},

    {.name = "PMIX_SERVER_REMOTE_CONNECTIONS", .string = "pmix.srvr.remote", .type = PMIX_BOOL,
     .description = (char *[]){"Allow connections from remote tools (do not use",
                               "loopback device)", NULL}},

    {.name = "PMIX_SERVER_SYSTEM_SUPPORT", .string = "pmix.srvr.sys", .type = PMIX_BOOL,
     .description = (char *[]){"The host RM wants to declare itself as being the",
                               "local system server for PMIx connection requests", NULL}},

    {.name = "PMIX_SERVER_SESSION_SUPPORT", .string = "pmix.srvr.sess", .type = PMIX_BOOL,
     .description = (char *[]){"The host RM wants to declare itself as being the",
                               "local session server for PMIx connection requests", NULL}},

    {.name = "PMIX_SERVER_TMPDIR", .string = "pmix.srvr.tmpdir", .type = PMIX_STRING,
     .description = (char *[]){"temp directory where PMIx server will place client",
                               "rendezvous points and contact info", NULL}},

    {.name = "PMIX_SYSTEM_TMPDIR", .string = "pmix.sys.tmpdir", .type = PMIX_STRING,
     .description = (char *[]){"temp directory for this system, where PMIx server",
                               "will place tool rendezvous points and contact info", NULL}},

    {.name = "PMIX_SERVER_SHARE_TOPOLOGY", .string = "pmix.srvr.share", .type = PMIX_BOOL,
     .description = (char *[]){"server is to share its copy of the local node",
                               "topology (whether given to it or self-discovered)",
                               "with any clients.", NULL}},

    {.name = "PMIX_SERVER_ENABLE_MONITORING", .string = "pmix.srv.monitor", .type = PMIX_BOOL,
     .description = (char *[]){"Enable PMIx internal monitoring by server", NULL}},

    {.name = "PMIX_SERVER_NSPACE", .string = "pmix.srv.nspace", .type = PMIX_STRING,
     .description = (char *[]){"Name of the nspace to use for this server", NULL}},

    {.name = "PMIX_SERVER_RANK", .string = "pmix.srv.rank", .type = PMIX_PROC_RANK,
     .description = (char *[]){"Rank of this server", NULL}},

    {.name = "PMIX_SERVER_GATEWAY", .string = "pmix.srv.gway", .type = PMIX_BOOL,
     .description = (char *[]){"Server is acting as a gateway for PMIx requests that",
                               "cannot be serviced on backend nodes (e.g., logging to",
                               "email)", NULL}},

    {.name = "PMIX_SERVER_SCHEDULER", .string = "pmix.srv.sched", .type = PMIX_BOOL,
     .description = (char *[]){"Server supports system scheduler", NULL}},

    {.name = "PMIX_SERVER_START_TIME", .string = "pmix.srv.strtime", .type = PMIX_STRING,
     .description = (char *[]){"Time when the server started - i.e., when the server",
                               "created it's rendezvous file (given in ctime string",
                               "format)", NULL}},

    {.name = "PMIX_HOMOGENEOUS_SYSTEM", .string = "pmix.homo", .type = PMIX_BOOL,
     .description = (char *[]){"The nodes comprising the session are homogeneous -",
                               "i.e., they each contain the same number of identical",
                               "packages, fabric interfaces, GPU, and other devices", NULL}},

    {.name = "PMIX_TOOL_NSPACE", .string = "pmix.tool.nspace", .type = PMIX_STRING,
     .description = (char *[]){"Name of the nspace to use for this tool", NULL}},

    {.name = "PMIX_TOOL_RANK", .string = "pmix.tool.rank", .type = PMIX_UINT32,
     .description = (char *[]){"Rank of this tool", NULL}},

    {.name = "PMIX_SERVER_PIDINFO", .string = "pmix.srvr.pidinfo", .type = PMIX_PID,
     .description = (char *[]){"pid of the target server for a tool", NULL}},

    {.name = "PMIX_CONNECT_TO_SYSTEM", .string = "pmix.cnct.sys", .type = PMIX_BOOL,
     .description = (char *[]){"The requestor requires that a connection be made only",
                               "to a local system-level PMIx server", NULL}},

    {.name = "PMIX_CONNECT_SYSTEM_FIRST", .string = "pmix.cnct.sys.first", .type = PMIX_BOOL,
     .description = (char *[]){"Preferentially look for a system-level PMIx server",
                               "first", NULL}},

    {.name = "PMIX_SERVER_URI", .string = "pmix.srvr.uri", .type = PMIX_STRING,
     .description = (char *[]){"URI of server to be contacted", NULL}},

    {.name = "PMIX_SERVER_HOSTNAME", .string = "pmix.srvr.host", .type = PMIX_STRING,
     .description = (char *[]){"node where target server is located", NULL}},

    {.name = "PMIX_CONNECT_MAX_RETRIES", .string = "pmix.tool.mretries", .type = PMIX_UINT32,
     .description = (char *[]){"maximum number of times to try to connect to server", NULL}},

    {.name = "PMIX_CONNECT_RETRY_DELAY", .string = "pmix.tool.retry", .type = PMIX_UINT32,
     .description = (char *[]){"time in seconds between connection attempts", NULL}},

    {.name = "PMIX_TOOL_DO_NOT_CONNECT", .string = "pmix.tool.nocon", .type = PMIX_BOOL,
     .description = (char *[]){"the tool wants to use internal PMIx support, but does",
                               "not want to connect to a PMIx server from the",
                               "specified processes to this tool", NULL}},

    {.name = "PMIX_TOOL_CONNECT_OPTIONAL", .string = "pmix.tool.conopt", .type = PMIX_BOOL,
     .description = (char *[]){"tool shall connect to a server if available, but",
                               "otherwise continue to operate unconnected", NULL}},

    {.name = "PMIX_LAUNCHER", .string = "pmix.tool.launcher", .type = PMIX_BOOL,
     .description = (char *[]){"tool is a launcher and needs rendezvous files created", NULL}},

    {.name = "PMIX_LAUNCHER_RENDEZVOUS_FILE", .string = "pmix.tool.lncrnd", .type = PMIX_STRING,
     .description = (char *[]){"Pathname of file where connection info is to be",
                               "stored", NULL}},

    {.name = "PMIX_TOOL_ATTACHMENT_FILE", .string = "pmix.tool.attach", .type = PMIX_STRING,
     .description = (char *[]){"File containing connection info to be used for",
                               "attaching to server", NULL}},

    {.name = "PMIX_PRIMARY_SERVER", .string = "pmix.pri.srvr", .type = PMIX_BOOL,
     .description = (char *[]){"The server to which the tool is connecting shall be",
                               "designated the primary server once connection has",
                               "been accomplished.", NULL}},

    {.name = "PMIX_NOHUP", .string = "pmix.nohup", .type = PMIX_BOOL,
     .description = (char *[]){"Any processes started on behalf of the calling tool",
                               "(or the specified namespace, if such specification is",
                               "included in the list of attributes) should continue",
                               "after the tool disconnects from its server", NULL}},

    {.name = "PMIX_LAUNCHER_DAEMON", .string = "pmix.lnch.dmn", .type = PMIX_STRING,
     .description = (char *[]){"Path to executable that is to be used as the backend",
                               "daemon for the launcher. This replaces the launcher's",
                               "own daemon with the specified executable. Note that",
                               "the user is therefore responsible for ensuring",
                               "compatibility of the specified executable and the",
                               "host launcher.", NULL}},

    {.name = "PMIX_EXEC_AGENT", .string = "pmix.exec.agnt", .type = PMIX_STRING,
     .description = (char *[]){"Path to executable that the launcher's backend",
                               "daemons are to fork/exec in place of the actual",
                               "application processes. The launcher's daemon shall",
                               "pass the full command line of the application on the",
                               "command line of the exec agent, which shall not",
                               "connect back to the launcher's daemon. The exec agent",
                               "is responsible for exec'ing the specified application",
                               "process in its own place.", NULL}},

    {.name = "PMIX_USERID", .string = "pmix.euid", .type = PMIX_UINT32,
     .description = (char *[]){"effective user id", NULL}},

    {.name = "PMIX_GRPID", .string = "pmix.egid", .type = PMIX_UINT32,
     .description = (char *[]){"effective group id", NULL}},

    {.name = "PMIX_VERSION_INFO", .string = "pmix.version", .type = PMIX_STRING,
     .description = (char *[]){"PMIx version of contactor", NULL}},

    {.name = "PMIX_REQUESTOR_IS_TOOL", .string = "pmix.req.tool", .type = PMIX_BOOL,
     .description = (char *[]){"requesting process is a tool", NULL}},

    {.name = "PMIX_REQUESTOR_IS_CLIENT", .string = "pmix.req.client", .type = PMIX_BOOL,
     .description = (char *[]){"requesting process is a client process", NULL}},

    {.name = "PMIX_PSET_NAME", .string = "pmix.pset.nm", .type = PMIX_STRING,
     .description = (char *[]){"The name of the newly defined process set.", NULL}},

    {.name = "PMIX_PSET_NAMES", .string = "pmix.pset.nms", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Returns an array of string names of the process sets",
                               "in which the given process is a member.", NULL}},

    {.name = "PMIX_PSET_MEMBERS", .string = "pmix.pset.mems", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"An array of pmix_proc_t containing the members of the",
                               "newly defined process set.", NULL}},

    {.name = "PMIX_REINCARNATION", .string = "pmix.reinc", .type = PMIX_UINT32,
     .description = (char *[]){"number of times this process has been instantiated -",
                               "i.e., tracks the number of times it has been",
                               "restarted", NULL}},

    {.name = "PMIX_PROGRAMMING_MODEL", .string = "pmix.pgm.model", .type = PMIX_STRING,
     .description = (char *[]){"programming model being initialized (e.g., \"MPI\" or",
                               "\"OpenMP\")", NULL}},

    {.name = "PMIX_MODEL_LIBRARY_NAME", .string = "pmix.mdl.name", .type = PMIX_STRING,
     .description = (char *[]){"programming model implementation ID (e.g.,",
                               "\"OpenMPI\" or \"MPICH\")", NULL}},

    {.name = "PMIX_MODEL_LIBRARY_VERSION", .string = "pmix.mld.vrs", .type = PMIX_STRING,
     .description = (char *[]){"programming model version string (e.g., \"2.1.1\")", NULL}},

    {.name = "PMIX_THREADING_MODEL", .string = "pmix.threads", .type = PMIX_STRING,
     .description = (char *[]){"threading model used (e.g., \"pthreads\")", NULL}},

    {.name = "PMIX_MODEL_NUM_THREADS", .string = "pmix.mdl.nthrds", .type = PMIX_UINT64,
     .description = (char *[]){"number of active threads being used by the model", NULL}},

    {.name = "PMIX_MODEL_NUM_CPUS", .string = "pmix.mdl.ncpu", .type = PMIX_UINT64,
     .description = (char *[]){"number of cpus being used by the model", NULL}},

    {.name = "PMIX_MODEL_CPU_TYPE", .string = "pmix.mdl.cputype", .type = PMIX_STRING,
     .description = (char *[]){"granularity - \"hwthread\", \"core\", etc.", NULL}},

    {.name = "PMIX_MODEL_PHASE_NAME", .string = "pmix.mdl.phase", .type = PMIX_STRING,
     .description = (char *[]){"user-assigned name for a phase in the application",
                               "execution - e.g., \"cfd reduction\"", NULL}},

    {.name = "PMIX_MODEL_PHASE_TYPE", .string = "pmix.mdl.ptype", .type = PMIX_STRING,
     .description = (char *[]){"type of phase being executed - e.g., \"matrix",
                               "multiply\"", NULL}},

    {.name = "PMIX_MODEL_AFFINITY_POLICY", .string = "pmix.mdl.tap", .type = PMIX_STRING,
     .description = (char *[]){"thread affinity policy - e.g.: \"master\" (thread",
                               "co-located with master thread), \"close\" (thread",
                               "located on cpu close to master thread) \"spread\"",
                               "(threads load-balanced across available cpus)", NULL}},

    {.name = "PMIX_USOCK_DISABLE", .string = "pmix.usock.disable", .type = PMIX_BOOL,
     .description = (char *[]){"disable legacy usock support", NULL}},

    {.name = "PMIX_SOCKET_MODE", .string = "pmix.sockmode", .type = PMIX_UINT32,
     .description = (char *[]){"POSIX mode_t (9 bits valid)", NULL}},

    {.name = "PMIX_SINGLE_LISTENER", .string = "pmix.sing.listnr", .type = PMIX_BOOL,
     .description = (char *[]){"use only one rendezvous socket, letting priorities",
                               "and/or MCA param select the active transport", NULL}},

    {.name = "PMIX_TCP_REPORT_URI", .string = "pmix.tcp.repuri", .type = PMIX_STRING,
     .description = (char *[]){"output URI - '-' => stdout, '+' => stderr, or",
                               "filename", NULL}},

    {.name = "PMIX_TCP_URI", .string = "pmix.tcp.uri", .type = PMIX_STRING,
     .description = (char *[]){"URI of server to connect to, or file:<name of file",
                               "containing it>", NULL}},

    {.name = "PMIX_TCP_IF_INCLUDE", .string = "pmix.tcp.ifinclude", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of devices and/or CIDR notation", NULL}},

    {.name = "PMIX_TCP_IF_EXCLUDE", .string = "pmix.tcp.ifexclude", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of devices and/or CIDR notation", NULL}},

    {.name = "PMIX_TCP_IPV4_PORT", .string = "pmix.tcp.ipv4", .type = PMIX_INT,
     .description = (char *[]){"IPv4 port to be used", NULL}},

    {.name = "PMIX_TCP_IPV6_PORT", .string = "pmix.tcp.ipv6", .type = PMIX_INT,
     .description = (char *[]){"IPv6 port to be used", NULL}},

    {.name = "PMIX_TCP_DISABLE_IPV4", .string = "pmix.tcp.disipv4", .type = PMIX_BOOL,
     .description = (char *[]){"true to disable IPv4 family", NULL}},

    {.name = "PMIX_TCP_DISABLE_IPV6", .string = "pmix.tcp.disipv6", .type = PMIX_BOOL,
     .description = (char *[]){"true to disable IPv6 family", NULL}},

    {.name = "PMIX_CPUSET", .string = "pmix.cpuset", .type = PMIX_STRING,
     .description = (char *[]){"String representation of bitmap applied to process",
                               "upon launch", NULL}},

    {.name = "PMIX_CPUSET_BITMAP", .string = "pmix.bitmap", .type = PMIX_PROC_CPUSET,
     .description = (char *[]){"Bitmap applied to process at launch", NULL}},

    {.name = "PMIX_CREDENTIAL", .string = "pmix.cred", .type = PMIX_STRING,
     .description = (char *[]){"security credential assigned to proc", NULL}},

    {.name = "PMIX_SPAWNED", .string = "pmix.spawned", .type = PMIX_BOOL,
     .description = (char *[]){"true if this proc resulted from a call to PMIx_Spawn", NULL}},

    {.name = "PMIX_TMPDIR", .string = "pmix.tmpdir", .type = PMIX_STRING,
     .description = (char *[]){"top-level tmp dir assigned to session", NULL}},

    {.name = "PMIX_NSDIR", .string = "pmix.nsdir", .type = PMIX_STRING,
     .description = (char *[]){"sub-tmpdir assigned to namespace", NULL}},

    {.name = "PMIX_PROCDIR", .string = "pmix.pdir", .type = PMIX_STRING,
     .description = (char *[]){"sub-nsdir assigned to proc", NULL}},

    {.name = "PMIX_TDIR_RMCLEAN", .string = "pmix.tdir.rmclean", .type = PMIX_BOOL,
     .description = (char *[]){"Resource Manager will clean session directories", NULL}},

    {.name = "PMIX_CLUSTER_ID", .string = "pmix.clid", .type = PMIX_STRING,
     .description = (char *[]){"a string name for the cluster this proc is executing",
                               "on", NULL}},

    {.name = "PMIX_PROCID", .string = "pmix.procid", .type = PMIX_PROC,
     .description = (char *[]){"process identifier", NULL}},

    {.name = "PMIX_NSPACE", .string = "pmix.nspace", .type = PMIX_STRING,
     .description = (char *[]){"nspace of a job", NULL}},

    {.name = "PMIX_JOBID", .string = "pmix.jobid", .type = PMIX_STRING,
     .description = (char *[]){"jobid assigned by scheduler", NULL}},

    {.name = "PMIX_APPNUM", .string = "pmix.appnum", .type = PMIX_UINT32,
     .description = (char *[]){"app number within the job", NULL}},

    {.name = "PMIX_RANK", .string = "pmix.rank", .type = PMIX_PROC_RANK,
     .description = (char *[]){"process rank within the job", NULL}},

    {.name = "PMIX_GLOBAL_RANK", .string = "pmix.grank", .type = PMIX_PROC_RANK,
     .description = (char *[]){"rank spanning across all jobs in this session", NULL}},

    {.name = "PMIX_APP_RANK", .string = "pmix.apprank", .type = PMIX_PROC_RANK,
     .description = (char *[]){"rank within this app", NULL}},

    {.name = "PMIX_NPROC_OFFSET", .string = "pmix.offset", .type = PMIX_PROC_RANK,
     .description = (char *[]){"starting global rank of this job", NULL}},

    {.name = "PMIX_LOCAL_RANK", .string = "pmix.lrank", .type = PMIX_UINT16,
     .description = (char *[]){"rank on this node within this job", NULL}},

    {.name = "PMIX_NODE_RANK", .string = "pmix.nrank", .type = PMIX_UINT16,
     .description = (char *[]){"rank on this node spanning all jobs", NULL}},

    {.name = "PMIX_PACKAGE_RANK", .string = "pmix.pkgrank", .type = PMIX_UINT16,
     .description = (char *[]){"rank within this job on the package where this proc",
                               "resides", NULL}},

    {.name = "PMIX_LOCALLDR", .string = "pmix.lldr", .type = PMIX_PROC_RANK,
     .description = (char *[]){"lowest rank on this node within this job", NULL}},

    {.name = "PMIX_APPLDR", .string = "pmix.aldr", .type = PMIX_PROC_RANK,
     .description = (char *[]){"lowest rank in this app within this job", NULL}},

    {.name = "PMIX_PROC_PID", .string = "pmix.ppid", .type = PMIX_PID,
     .description = (char *[]){"pid of specified proc", NULL}},

    {.name = "PMIX_SESSION_ID", .string = "pmix.session.id", .type = PMIX_UINT32,
     .description = (char *[]){"session identifier", NULL}},

    {.name = "PMIX_NODE_LIST", .string = "pmix.nlist", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of nodes running procs for the",
                               "specified nspace", NULL}},

    {.name = "PMIX_ALLOCATED_NODELIST", .string = "pmix.alist", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of all nodes in this allocation",
                               "regardless of whether or not they currently host",
                               "procs.", NULL}},

    {.name = "PMIX_HOSTNAME", .string = "pmix.hname", .type = PMIX_STRING,
     .description = (char *[]){"name of the host the specified proc is on", NULL}},

    {.name = "PMIX_HOSTNAME_ALIASES", .string = "pmix.alias", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of names by which this node is",
                               "known", NULL}},

    {.name = "PMIX_HOSTNAME_KEEP_FQDN", .string = "pmix.fqdn", .type = PMIX_BOOL,
     .description = (char *[]){"FQDN hostnames are being retained", NULL}},

    {.name = "PMIX_NODEID", .string = "pmix.nodeid", .type = PMIX_UINT32,
     .description = (char *[]){"node identifier where the specified proc is located", NULL}},

    {.name = "PMIX_LOCAL_PEERS", .string = "pmix.lpeers", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited string of ranks on this node within",
                               "the specified nspace", NULL}},

    {.name = "PMIX_LOCAL_PROCS", .string = "pmix.lprocs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_proc_t of procs on the specified node", NULL}},

    {.name = "PMIX_LOCAL_CPUSETS", .string = "pmix.lcpus", .type = PMIX_STRING,
     .description = (char *[]){"colon-delimited cpusets of local peers within the",
                               "specified nspace", NULL}},

    {.name = "PMIX_PARENT_ID", .string = "pmix.parent", .type = PMIX_PROC,
     .description = (char *[]){"identifier of the process that called PMIx_Spawn to",
                               "launch this proc's application", NULL}},

    {.name = "PMIX_EXIT_CODE", .string = "pmix.exit.code", .type = PMIX_INT,
     .description = (char *[]){"exit code returned when proc terminated", NULL}},

    {.name = "PMIX_UNIV_SIZE", .string = "pmix.univ.size", .type = PMIX_UINT32,
     .description = (char *[]){"#slots in this session", NULL}},

    {.name = "PMIX_JOB_SIZE", .string = "pmix.job.size", .type = PMIX_UINT32,
     .description = (char *[]){"#procs in this job", NULL}},

    {.name = "PMIX_JOB_NUM_APPS", .string = "pmix.job.napps", .type = PMIX_UINT32,
     .description = (char *[]){"#apps in this job", NULL}},

    {.name = "PMIX_APP_SIZE", .string = "pmix.app.size", .type = PMIX_UINT32,
     .description = (char *[]){"#procs in this application", NULL}},

    {.name = "PMIX_LOCAL_SIZE", .string = "pmix.local.size", .type = PMIX_UINT32,
     .description = (char *[]){"#procs in this job on this node", NULL}},

    {.name = "PMIX_NODE_SIZE", .string = "pmix.node.size", .type = PMIX_UINT32,
     .description = (char *[]){"#procs across all jobs on this node", NULL}},

    {.name = "PMIX_MAX_PROCS", .string = "pmix.max.size", .type = PMIX_UINT32,
     .description = (char *[]){"max #procs for this job", NULL}},

    {.name = "PMIX_NUM_SLOTS", .string = "pmix.num.slots", .type = PMIX_UINT32,
     .description = (char *[]){"#slots allocated", NULL}},

    {.name = "PMIX_NUM_NODES", .string = "pmix.num.nodes", .type = PMIX_UINT32,
     .description = (char *[]){"#nodes currently hosting processes in the specified",
                               "realm.", NULL}},

    {.name = "PMIX_NUM_ALLOCATED_NODES", .string = "pmix.num.anodes", .type = PMIX_UINT32,
     .description = (char *[]){"#nodes in the specified realm regardless of whether",
                               "or not they currently host processes.", NULL}},

    {.name = "PMIX_AVAIL_PHYS_MEMORY", .string = "pmix.pmem", .type = PMIX_UINT64,
     .description = (char *[]){"total available physical memory on this node", NULL}},

    {.name = "PMIX_DAEMON_MEMORY", .string = "pmix.dmn.mem", .type = PMIX_FLOAT,
     .description = (char *[]){"Mbytes of memory currently used by daemon", NULL}},

    {.name = "PMIX_CLIENT_AVG_MEMORY", .string = "pmix.cl.mem.avg", .type = PMIX_FLOAT,
     .description = (char *[]){"Average Mbytes of memory used by client processes", NULL}},

    {.name = "PMIX_TOPOLOGY2", .string = "pmix.topo2", .type = PMIX_TOPO,
     .description = (char *[]){"pointer to a PMIx topology object", NULL}},

    {.name = "PMIX_LOCALITY_STRING", .string = "pmix.locstr", .type = PMIX_STRING,
     .description = (char *[]){"string describing a proc's location", NULL}},

    {.name = "PMIX_COLLECT_DATA", .string = "pmix.collect", .type = PMIX_BOOL,
     .description = (char *[]){"collect data and return it at the end of the",
                               "operation", NULL}},

    {.name = "PMIX_ALL_CLONES_PARTICIPATE", .string = "pmix.clone.part", .type = PMIX_BOOL,
     .description = (char *[]){"All clones of the calling process must participate in",
                               "the collective operation.", NULL}},

    {.name = "PMIX_COLLECT_GENERATED_JOB_INFO", .string = "pmix.collect.gen", .type = PMIX_BOOL,
     .description = (char *[]){"Collect all job-level information (i.e., reserved",
                               "keys) that was locally generated by PMIx servers.",
                               "Some job-level information (e.g., distance between",
                               "processes and fabric devices) is best determined on a",
                               "distributed basis as it primarily pertains to local",
                               "processes. Should remote processes need to access the",
                               "information, it can either be obtained collectively",
                               "using the PMIx_Fence operation with this directive,",
                               "or can be retrieved one peer at a time using PMIx_Get",
                               "without first having performed the job-wide",
                               "collection.", NULL}},

    {.name = "PMIX_TIMEOUT", .string = "pmix.timeout", .type = PMIX_INT,
     .description = (char *[]){"time in sec before specified operation should time",
                               "out (0 => infinite)", NULL}},

    {.name = "PMIX_IMMEDIATE", .string = "pmix.immediate", .type = PMIX_BOOL,
     .description = (char *[]){"specified operation should immediately return an",
                               "error from the PMIx server if requested data cannot",
                               "be found - do not request it from the host RM", NULL}},

    {.name = "PMIX_WAIT", .string = "pmix.wait", .type = PMIX_INT,
     .description = (char *[]){"caller requests that the server wait until at least",
                               "the specified #values are found (0 => all and is the",
                               "default)", NULL}},

    {.name = "PMIX_NOTIFY_COMPLETION", .string = "pmix.notecomp", .type = PMIX_BOOL,
     .description = (char *[]){"notify parent process upon termination of child job", NULL}},

    {.name = "PMIX_RANGE", .string = "pmix.range", .type = PMIX_UINT8,
     .description = (char *[]){"value for calls to publish/lookup/unpublish or for",
                               "monitoring event notifications", NULL}},

    {.name = "PMIX_PERSISTENCE", .string = "pmix.persist", .type = PMIX_UINT8,
     .description = (char *[]){"value for calls to publish", NULL}},

    {.name = "PMIX_DATA_SCOPE", .string = "pmix.scope", .type = PMIX_UINT8,
     .description = (char *[]){"scope of the data to be found in a PMIx_Get call", NULL}},

    {.name = "PMIX_OPTIONAL", .string = "pmix.optional", .type = PMIX_BOOL,
     .description = (char *[]){"look only in the client's local data store for the",
                               "requested value - do not request data from the server",
                               "if not found", NULL}},

    {.name = "PMIX_GET_STATIC_VALUES", .string = "pmix.get.static", .type = PMIX_BOOL,
     .description = (char *[]){"Request that the data be returned in the provided",
                               "storage location", NULL}},

    {.name = "PMIX_GET_POINTER_VALUES", .string = "pmix.get.pntrs", .type = PMIX_BOOL,
     .description = (char *[]){"Request that any pointers in the returned value point",
                               "directly to values in the key-value store", NULL}},

    {.name = "PMIX_EMBED_BARRIER", .string = "pmix.embed.barrier", .type = PMIX_BOOL,
     .description = (char *[]){"execute a blocking fence operation before executing",
                               "the specified operation", NULL}},

    {.name = "PMIX_JOB_TERM_STATUS", .string = "pmix.job.term.status", .type = PMIX_STATUS,
     .description = (char *[]){"status returned upon job termination", NULL}},

    {.name = "PMIX_PROC_TERM_STATUS", .string = "pmix.proc.term.status", .type = PMIX_STATUS,
     .description = (char *[]){"status returned upon process termination", NULL}},

    {.name = "PMIX_PROC_STATE_STATUS", .string = "pmix.proc.state", .type = PMIX_PROC_STATE,
     .description = (char *[]){"process state", NULL}},

    {.name = "PMIX_GET_REFRESH_CACHE", .string = "pmix.get.refresh", .type = PMIX_BOOL,
     .description = (char *[]){"when retrieving data for a remote process, refresh",
                               "the existing local data cache for the process in case",
                               "new values have been put and committed by it since",
                               "the last refresh", NULL}},

    {.name = "PMIX_ACCESS_PERMISSIONS", .string = "pmix.aperms", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Define access permissions for the published data. The",
                               "value shall contain an array of pmix_info_t structs",
                               "containing the specified permissions.", NULL}},

    {.name = "PMIX_ACCESS_USERIDS", .string = "pmix.auids", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Array of effective UIDs that are allowed to access",
                               "the published data", NULL}},

    {.name = "PMIX_ACCESS_GRPIDS", .string = "pmix.agids", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Array of effective GIDs that are allowed to access",
                               "the published data", NULL}},

    {.name = "PMIX_REGISTER_NODATA", .string = "pmix.reg.nodata", .type = PMIX_BOOL,
     .description = (char *[]){"Registration is for nspace only, do not copy job data", NULL}},

    {.name = "PMIX_NODE_MAP", .string = "pmix.nmap", .type = PMIX_STRING,
     .description = (char *[]){"regex of nodes containing procs for this job", NULL}},

    {.name = "PMIX_NODE_MAP_RAW", .string = "pmix.nmap.raw", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of nodes containing procs for",
                               "this job", NULL}},

    {.name = "PMIX_PROC_MAP", .string = "pmix.pmap", .type = PMIX_STRING,
     .description = (char *[]){"regex describing procs on each node within this job", NULL}},

    {.name = "PMIX_PROC_MAP_RAW", .string = "pmix.pmap.raw", .type = PMIX_STRING,
     .description = (char *[]){"semi-colon delimited list of strings, each string",
                               "containing a comma-delimited list of ranks on the",
                               "corresponding node", NULL}},

    {.name = "PMIX_ANL_MAP", .string = "pmix.anlmap", .type = PMIX_STRING,
     .description = (char *[]){"process mapping in ANL notation (used in PMI-1/PMI-2)", NULL}},

    {.name = "PMIX_APP_MAP_TYPE", .string = "pmix.apmap.type", .type = PMIX_STRING,
     .description = (char *[]){"type of mapping used to layout the application (e.g.,",
                               "cyclic)", NULL}},

    {.name = "PMIX_APP_MAP_REGEX", .string = "pmix.apmap.regex", .type = PMIX_STRING,
     .description = (char *[]){"regex describing the result of the mapping", NULL}},

    {.name = "PMIX_REQUIRED_KEY", .string = "pmix.req.key", .type = PMIX_STRING,
     .description = (char *[]){"key the user needs prior to responding from a dmodex",
                               "request", NULL}},

    {.name = "PMIX_EVENT_HDLR_NAME", .string = "pmix.evname", .type = PMIX_STRING,
     .description = (char *[]){"string name identifying this handler", NULL}},

    {.name = "PMIX_EVENT_HDLR_FIRST", .string = "pmix.evfirst", .type = PMIX_BOOL,
     .description = (char *[]){"invoke this event handler before any other handlers", NULL}},

    {.name = "PMIX_EVENT_HDLR_LAST", .string = "pmix.evlast", .type = PMIX_BOOL,
     .description = (char *[]){"invoke this event handler after all other handlers",
                               "have been called", NULL}},

    {.name = "PMIX_EVENT_HDLR_FIRST_IN_CATEGORY", .string = "pmix.evfirstcat", .type = PMIX_BOOL,
     .description = (char *[]){"invoke this event handler before any other handlers",
                               "in this category", NULL}},

    {.name = "PMIX_EVENT_HDLR_LAST_IN_CATEGORY", .string = "pmix.evlastcat", .type = PMIX_BOOL,
     .description = (char *[]){"invoke this event handler after all other handlers in",
                               "this category have been called", NULL}},

    {.name = "PMIX_EVENT_HDLR_BEFORE", .string = "pmix.evbefore", .type = PMIX_STRING,
     .description = (char *[]){"put this event handler immediately before the one",
                               "specified in the (char*) value", NULL}},

    {.name = "PMIX_EVENT_HDLR_AFTER", .string = "pmix.evafter", .type = PMIX_STRING,
     .description = (char *[]){"put this event handler immediately after the one",
                               "specified in the (char*) value", NULL}},

    {.name = "PMIX_EVENT_HDLR_PREPEND", .string = "pmix.evprepend", .type = PMIX_BOOL,
     .description = (char *[]){"prepend this handler to the precedence list within",
                               "its category", NULL}},

    {.name = "PMIX_EVENT_HDLR_APPEND", .string = "pmix.evappend", .type = PMIX_BOOL,
     .description = (char *[]){"append this handler to the precedence list within its",
                               "category", NULL}},

    {.name = "PMIX_EVENT_CUSTOM_RANGE", .string = "pmix.evrange", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_proc_t defining range of event",
                               "notification", NULL}},

    {.name = "PMIX_EVENT_AFFECTED_PROC", .string = "pmix.evproc", .type = PMIX_PROC,
     .description = (char *[]){"single proc that was affected", NULL}},

    {.name = "PMIX_EVENT_AFFECTED_PROCS", .string = "pmix.evaffected", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_proc_t defining affected procs", NULL}},

    {.name = "PMIX_EVENT_NON_DEFAULT", .string = "pmix.evnondef", .type = PMIX_BOOL,
     .description = (char *[]){"event is not to be delivered to default event",
                               "handlers", NULL}},

    {.name = "PMIX_EVENT_RETURN_OBJECT", .string = "pmix.evobject", .type = PMIX_POINTER,
     .description = (char *[]){"object to be returned whenever the registered cbfunc",
                               "is invoked NOTE: the object will _only_ be returned",
                               "to the process that registered it", NULL}},

    {.name = "PMIX_EVENT_DO_NOT_CACHE", .string = "pmix.evnocache", .type = PMIX_BOOL,
     .description = (char *[]){"instruct the PMIx server not to cache the event", NULL}},

    {.name = "PMIX_EVENT_SILENT_TERMINATION", .string = "pmix.evsilentterm", .type = PMIX_BOOL,
     .description = (char *[]){"do not generate an event when this job normally",
                               "terminates", NULL}},

    {.name = "PMIX_EVENT_PROXY", .string = "pmix.evproxy", .type = PMIX_PROC,
     .description = (char *[]){"PMIx server that sourced the event", NULL}},

    {.name = "PMIX_EVENT_TEXT_MESSAGE", .string = "pmix.evtext", .type = PMIX_STRING,
     .description = (char *[]){"text message suitable for output by recipient - e.g.,",
                               "describing the cause of the event", NULL}},

    {.name = "PMIX_EVENT_TIMESTAMP", .string = "pmix.evtstamp", .type = PMIX_TIME,
     .description = (char *[]){"System time when the associated event occurred.", NULL}},

    {.name = "PMIX_EVENT_TERMINATE_SESSION", .string = "pmix.evterm.sess", .type = PMIX_BOOL,
     .description = (char *[]){"RM intends to terminate session", NULL}},

    {.name = "PMIX_EVENT_TERMINATE_JOB", .string = "pmix.evterm.job", .type = PMIX_BOOL,
     .description = (char *[]){"RM intends to terminate this job", NULL}},

    {.name = "PMIX_EVENT_TERMINATE_NODE", .string = "pmix.evterm.node", .type = PMIX_BOOL,
     .description = (char *[]){"RM intends to terminate all procs on this node", NULL}},

    {.name = "PMIX_EVENT_TERMINATE_PROC", .string = "pmix.evterm.proc", .type = PMIX_BOOL,
     .description = (char *[]){"RM intends to terminate just this process", NULL}},

    {.name = "PMIX_EVENT_ACTION_TIMEOUT", .string = "pmix.evtimeout", .type = PMIX_INT,
     .description = (char *[]){"time in sec before RM will execute error response", NULL}},

    {.name = "PMIX_PERSONALITY", .string = "pmix.pers", .type = PMIX_STRING,
     .description = (char *[]){"name of personality to use", NULL}},

    {.name = "PMIX_HOST", .string = "pmix.host", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of hosts to use for spawned",
                               "procs", NULL}},

    {.name = "PMIX_HOSTFILE", .string = "pmix.hostfile", .type = PMIX_STRING,
     .description = (char *[]){"hostfile to use for spawned procs", NULL}},

    {.name = "PMIX_ADD_HOST", .string = "pmix.addhost", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of hosts to add to allocation", NULL}},

    {.name = "PMIX_ADD_HOSTFILE", .string = "pmix.addhostfile", .type = PMIX_STRING,
     .description = (char *[]){"hostfile to add to existing allocation", NULL}},

    {.name = "PMIX_PREFIX", .string = "pmix.prefix", .type = PMIX_STRING,
     .description = (char *[]){"prefix to use for starting spawned procs", NULL}},

    {.name = "PMIX_WDIR", .string = "pmix.wdir", .type = PMIX_STRING,
     .description = (char *[]){"working directory for spawned procs", NULL}},

    {.name = "PMIX_DISPLAY_MAP", .string = "pmix.dispmap", .type = PMIX_BOOL,
     .description = (char *[]){"display process map upon spawn", NULL}},

    {.name = "PMIX_PPR", .string = "pmix.ppr", .type = PMIX_STRING,
     .description = (char *[]){"#procs to spawn on each identified resource", NULL}},

    {.name = "PMIX_MAPBY", .string = "pmix.mapby", .type = PMIX_STRING,
     .description = (char *[]){"mapping policy", NULL}},

    {.name = "PMIX_RANKBY", .string = "pmix.rankby", .type = PMIX_STRING,
     .description = (char *[]){"ranking policy", NULL}},

    {.name = "PMIX_BINDTO", .string = "pmix.bindto", .type = PMIX_STRING,
     .description = (char *[]){"binding policy", NULL}},

    {.name = "PMIX_PRELOAD_BIN", .string = "pmix.preloadbin", .type = PMIX_BOOL,
     .description = (char *[]){"preload binaries", NULL}},

    {.name = "PMIX_PRELOAD_FILES", .string = "pmix.preloadfiles", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of files to pre-position", NULL}},

    {.name = "PMIX_STDIN_TGT", .string = "pmix.stdin", .type = PMIX_PROC,
     .description = (char *[]){"proc that is to receive stdin (PMIX_RANK_WILDCARD =",
                               "all in given nspace)", NULL}},

    {.name = "PMIX_DEBUGGER_DAEMONS", .string = "pmix.debugger", .type = PMIX_BOOL,
     .description = (char *[]){"spawned app consists of debugger daemons", NULL}},

    {.name = "PMIX_COSPAWN_APP", .string = "pmix.cospawn", .type = PMIX_BOOL,
     .description = (char *[]){"designated app is to be spawned as a disconnected job",
                               "- i.e., not part of the \"comm_world\" of the job", NULL}},

    {.name = "PMIX_SET_SESSION_CWD", .string = "pmix.ssncwd", .type = PMIX_BOOL,
     .description = (char *[]){"set the application's current working directory to",
                               "the session working directory assigned by the RM", NULL}},

    {.name = "PMIX_TAG_OUTPUT", .string = "pmix.tagout", .type = PMIX_BOOL,
     .description = (char *[]){"tag application output with the ID of the source", NULL}},

    {.name = "PMIX_TIMESTAMP_OUTPUT", .string = "pmix.tsout", .type = PMIX_BOOL,
     .description = (char *[]){"timestamp output from applications", NULL}},

    {.name = "PMIX_MERGE_STDERR_STDOUT", .string = "pmix.mergeerrout", .type = PMIX_BOOL,
     .description = (char *[]){"merge stdout and stderr streams from application",
                               "procs", NULL}},

    {.name = "PMIX_OUTPUT_TO_FILE", .string = "pmix.outfile", .type = PMIX_STRING,
     .description = (char *[]){"direct application output into files of form",
                               "\"<filename>.rank\" with both stdout and stderr",
                               "redirected into it", NULL}},

    {.name = "PMIX_OUTPUT_TO_DIRECTORY", .string = "pmix.outdir", .type = PMIX_STRING,
     .description = (char *[]){"direct application output into files of form",
                               "\"<directory>/<jobid>/rank.<rank>/stdout[err]\"", NULL}},

    {.name = "PMIX_INDEX_ARGV", .string = "pmix.indxargv", .type = PMIX_BOOL,
     .description = (char *[]){"mark the argv with the rank of the proc", NULL}},

    {.name = "PMIX_CPUS_PER_PROC", .string = "pmix.cpuperproc", .type = PMIX_UINT32,
     .description = (char *[]){"#cpus to assign to each rank", NULL}},

    {.name = "PMIX_NO_PROCS_ON_HEAD", .string = "pmix.nolocal", .type = PMIX_BOOL,
     .description = (char *[]){"do not place procs on the head node", NULL}},

    {.name = "PMIX_NO_OVERSUBSCRIBE", .string = "pmix.noover", .type = PMIX_BOOL,
     .description = (char *[]){"do not oversubscribe the cpus", NULL}},

    {.name = "PMIX_REPORT_BINDINGS", .string = "pmix.repbind", .type = PMIX_BOOL,
     .description = (char *[]){"report bindings of the individual procs", NULL}},

    {.name = "PMIX_CPU_LIST", .string = "pmix.cpulist", .type = PMIX_STRING,
     .description = (char *[]){"list of cpus to use for this job", NULL}},

    {.name = "PMIX_JOB_RECOVERABLE", .string = "pmix.recover", .type = PMIX_BOOL,
     .description = (char *[]){"application supports recoverable operations", NULL}},

    {.name = "PMIX_JOB_CONTINUOUS", .string = "pmix.continuous", .type = PMIX_BOOL,
     .description = (char *[]){"application is continuous, all failed procs should be",
                               "immediately restarted", NULL}},

    {.name = "PMIX_MAX_RESTARTS", .string = "pmix.maxrestarts", .type = PMIX_UINT32,
     .description = (char *[]){"max number of times to restart a job", NULL}},

    {.name = "PMIX_FWD_STDIN", .string = "pmix.fwd.stdin", .type = PMIX_BOOL,
     .description = (char *[]){"forward the stdin from this process to the target",
                               "processes", NULL}},

    {.name = "PMIX_FWD_STDOUT", .string = "pmix.fwd.stdout", .type = PMIX_BOOL,
     .description = (char *[]){"forward stdout from the spawned processes to this",
                               "process (typically used by a tool)", NULL}},

    {.name = "PMIX_FWD_STDERR", .string = "pmix.fwd.stderr", .type = PMIX_BOOL,
     .description = (char *[]){"forward stderr from the spawned processes to this",
                               "process (typically used by a tool)", NULL}},

    {.name = "PMIX_FWD_STDDIAG", .string = "pmix.fwd.stddiag", .type = PMIX_BOOL,
     .description = (char *[]){"if a diagnostic channel exists, forward any output on",
                               "it from the spawned processes to this process",
                               "(typically used by a tool)", NULL}},

    {.name = "PMIX_SPAWN_TOOL", .string = "pmix.spwn.tool", .type = PMIX_BOOL,
     .description = (char *[]){"job being spawned is a tool", NULL}},

    {.name = "PMIX_CMD_LINE", .string = "pmix.cmd.line", .type = PMIX_STRING,
     .description = (char *[]){"command line executing in the specified nspace", NULL}},

    {.name = "PMIX_FORKEXEC_AGENT", .string = "pmix.fe.agnt", .type = PMIX_STRING,
     .description = (char *[]){"command line of fork/exec agent to be used for",
                               "starting local processes", NULL}},

    {.name = "PMIX_TIMEOUT_STACKTRACES", .string = "pmix.tim.stack", .type = PMIX_BOOL,
     .description = (char *[]){"include process stacktraces in timeout report from a",
                               "job", NULL}},

    {.name = "PMIX_TIMEOUT_REPORT_STATE", .string = "pmix.tim.state", .type = PMIX_BOOL,
     .description = (char *[]){"report process states in timeout report from a job", NULL}},

    {.name = "PMIX_APP_ARGV", .string = "pmix.app.argv", .type = PMIX_STRING,
     .description = (char *[]){"consolidated argv passed to the spawn command for the",
                               "given app", NULL}},

    {.name = "PMIX_NOTIFY_JOB_EVENTS", .string = "pmix.note.jev", .type = PMIX_BOOL,
     .description = (char *[]){"Requests that the launcher generate the",
                               "PMIX_EVENT_JOB_START, PMIX_LAUNCH_COMPLETE, and",
                               "PMIX_EVENT_JOB_END events. Each event is to include",
                               "at least the namespace of the corresponding job and a",
                               "PMIX_EVENT_TIMESTAMP indicating the time the event",
                               "occurred.", NULL}},

    {.name = "PMIX_NOTIFY_PROC_TERMINATION", .string = "pmix.noteproc", .type = PMIX_BOOL,
     .description = (char *[]){"Requests that the launcher generate the",
                               "PMIX_EVENT_PROC_TERMINATED event whenever a process",
                               "either normally or abnormally terminates.", NULL}},

    {.name = "PMIX_NOTIFY_PROC_ABNORMAL_TERMINATION", .string = "pmix.noteabproc", .type = PMIX_BOOL,
     .description = (char *[]){"Requests that the launcher generate the",
                               "PMIX_EVENT_PROC_TERMINATED event only when a process",
                               "abnormally terminates.", NULL}},

    {.name = "PMIX_QUERY_SUPPORTED_KEYS", .string = "pmix.qry.keys", .type = PMIX_STRING,
     .description = (char *[]){"returns comma-delimited list of keys supported by the",
                               "query function. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_NAMESPACES", .string = "pmix.qry.ns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of active namespaces.",
                               "NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_NAMESPACE_INFO", .string = "pmix.qry.nsinfo", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns an array of active nspace information - each",
                               "element will contain an array including the namespace",
                               "plus the command line of the application executing",
                               "within it SUPPORTED QUALIFIERS: PMIX_NSPACE of",
                               "specific nspace whose info is being requested", NULL}},

    {.name = "PMIX_QUERY_JOB_STATUS", .string = "pmix.qry.jst", .type = PMIX_STATUS,
     .description = (char *[]){"returns status of a specified currently executing job",
                               "REQUIRES a PMIX_NSPACE qualifier indicating the",
                               "nspace being queried", NULL}},

    {.name = "PMIX_QUERY_QUEUE_LIST", .string = "pmix.qry.qlst", .type = PMIX_STRING,
     .description = (char *[]){"request a comma-delimited list of scheduler queues.",
                               "NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_QUEUE_STATUS", .string = "pmix.qry.qst", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns array where each element contains the name",
                               "and status of a scheduler queue SUPPORTED QUALIFIERS:",
                               "PMIX_ALLOC_QUEUE naming specific queue whose status",
                               "is being requested", NULL}},

    {.name = "PMIX_QUERY_PROC_TABLE", .string = "pmix.qry.ptable", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns (pmix_data_array_t*) an array of",
                               "pmix_proc_info_t REQUIRES a PMIX_NSPACE qualifier",
                               "indicating the nspace being queried", NULL}},

    {.name = "PMIX_QUERY_LOCAL_PROC_TABLE", .string = "pmix.qry.lptable", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns (pmix_data_array_t*) an array of",
                               "pmix_proc_info_t of pmix_proc_info_t for procs in job",
                               "on same node REQUIRES a PMIX_NSPACE qualifier",
                               "indicating the nspace being queried", NULL}},

    {.name = "PMIX_QUERY_AUTHORIZATIONS", .string = "pmix.qry.auths", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"return operations tool is authorized to perform. The",
                               "contents of the array elements have not yet been",
                               "standardized. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_SPAWN_SUPPORT", .string = "pmix.qry.spawn", .type = PMIX_STRING,
     .description = (char *[]){"return a comma-delimited list of supported spawn",
                               "attributes. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_DEBUG_SUPPORT", .string = "pmix.qry.debug", .type = PMIX_STRING,
     .description = (char *[]){"return a comma-delimited list of supported debug",
                               "attributes. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_MEMORY_USAGE", .string = "pmix.qry.mem", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"return info on memory usage for the procs indicated",
                               "in the qualifiers SUPPORTED QUALIFIERS:",
                               "PMIX_NSPACE/PMIX_RANK, or PMIX_PROCID of specific",
                               "proc(s) whose info is being requested", NULL}},

    {.name = "PMIX_QUERY_ALLOC_STATUS", .string = "pmix.query.alloc", .type = PMIX_STRING,
     .description = (char *[]){"return a string reporting status of an allocation",
                               "request REQUIRES a PMIX_ALLOC_ID qualifier indicating",
                               "the allocation request being queried", NULL}},

    {.name = "PMIX_TIME_REMAINING", .string = "pmix.time.remaining", .type = PMIX_UINT32,
     .description = (char *[]){"returns number of seconds remaining in allocation for",
                               "the specified nspace (defaults to allocation",
                               "containing the caller) SUPPORTED QUALIFIERS:",
                               "PMIX_NSPACE of the nspace whose info is being",
                               "requested", NULL}},

    {.name = "PMIX_QUERY_NUM_PSETS", .string = "pmix.qry.psetnum", .type = PMIX_SIZE,
     .description = (char *[]){"returns the number of psets defined in the specified",
                               "range (defaults to session) SUPPORTED QUALIFIERS:",
                               "PMIX_RANGE whose info is being requested", NULL}},

    {.name = "PMIX_QUERY_PSET_NAMES", .string = "pmix.qry.psets", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of the names of the",
                               "psets defined in the specified range (defaults to",
                               "session) SUPPORTED QUALIFIERS: PMIX_RANGE whose info",
                               "is being requested", NULL}},

    {.name = "PMIX_QUERY_PSET_MEMBERSHIP", .string = "pmix.qry.pmems", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Return an array of pmix_proc_t containing the members",
                               "of the specified process set.", NULL}},

    {.name = "PMIX_QUERY_NUM_GROUPS", .string = "pmix.qry.pgrpnum", .type = PMIX_SIZE,
     .description = (char *[]){"Return the number of process groups defined in the",
                               "specified range (defaults to session). OPTIONAL",
                               "QUALIFERS: PMIX_RANGE.", NULL}},

    {.name = "PMIX_QUERY_GROUP_NAMES", .string = "pmix.qry.pgrp", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Return a pmix_data_array_t containing an array of",
                               "string names of the process groups defined in the",
                               "specified range (defaults to session). OPTIONAL",
                               "QUALIFERS: PMIX_RANGE", NULL}},

    {.name = "PMIX_QUERY_GROUP_MEMBERSHIP", .string = "pmix.qry.pgrpmems", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Return a pmix_data_array_t of pmix_proc_t containing",
                               "the members of the specified process group. REQUIRED",
                               "QUALIFIERS: PMIX_GROUP_ID.", NULL}},

    {.name = "PMIX_QUERY_ATTRIBUTE_SUPPORT", .string = "pmix.qry.attrs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns array of pmix_info_t where each element",
                               "consists of a key containing the name of the",
                               "function, and an array of pmix_regattr_t detailing",
                               "the attribute support for that function SUPPORTED",
                               "QUALIFIERS: PMIX_CLIENT_FUNCTIONS,",
                               "PMIX_SERVER_FUNCTIONS, PMIX_TOOL_FUNCTIONS, and/or",
                               "PMIX_HOST_FUNCTIONS", NULL}},

    {.name = "PMIX_CLIENT_FUNCTIONS", .string = "pmix.client.fns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of supported PMIx",
                               "client functions. NO QUALIFIERS", NULL}},

    {.name = "PMIX_SERVER_FUNCTIONS", .string = "pmix.srvr.fns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of supported PMIx",
                               "server functions. NO QUALIFIERS", NULL}},

    {.name = "PMIX_TOOL_FUNCTIONS", .string = "pmix.tool.fns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of supported PMIx tool",
                               "functions. NO QUALIFIERS", NULL}},

    {.name = "PMIX_HOST_FUNCTIONS", .string = "pmix.host.fns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of PMIx functions",
                               "supported by the host environment", NULL}},

    {.name = "PMIX_QUERY_AVAIL_SERVERS", .string = "pmix.qry.asrvrs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_info_t, each element containing an",
                               "array of pmix_info_t of available data for servers on",
                               "this node to which the caller might be able to",
                               "connect. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_QUALIFIERS", .string = "pmix.qry.quals", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Contains an array of qualifiers that were included in",
                               "the query that produced the provided results. This",
                               "attribute is solely for reporting purposes and cannot",
                               "be used in PMIx_Get or other query operations", NULL}},

    {.name = "PMIX_QUERY_RESULTS", .string = "pmix.qry.res", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Contains an array of query results for a given",
                               "pmix_query_t passed to the PMIx_Query_info APIs. If",
                               "qualifiers were included in the query, then the first",
                               "element of the array shall be the",
                               "PMIX_QUERY_QUALIFIERS attribute containing those",
                               "qualifiers. Each of the remaining elements of the",
                               "array is a pmix_info_t containing the query key and",
                               "the corresponding value returned by the query. This",
                               "attribute is solely for reporting purposes and cannot",
                               "be used in PMIx_Get or other query operations", NULL}},

    {.name = "PMIX_QUERY_REFRESH_CACHE", .string = "pmix.qry.rfsh", .type = PMIX_BOOL,
     .description = (char *[]){"retrieve updated information from server to update",
                               "local cache", NULL}},

    {.name = "PMIX_QUERY_LOCAL_ONLY", .string = "pmix.qry.local", .type = PMIX_BOOL,
     .description = (char *[]){"constrain the query to local information only", NULL}},

    {.name = "PMIX_QUERY_REPORT_AVG", .string = "pmix.qry.avg", .type = PMIX_BOOL,
     .description = (char *[]){"report average values", NULL}},

    {.name = "PMIX_QUERY_REPORT_MINMAX", .string = "pmix.qry.minmax", .type = PMIX_BOOL,
     .description = (char *[]){"report minimum and maximum value", NULL}},

    {.name = "PMIX_CLIENT_ATTRIBUTES", .string = "pmix.client.attrs", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of functions, including \"all\"",
                               "when used in a query, indicates whether or not to",
                               "include attributes supported by the PMIx client",
                               "library", NULL}},

    {.name = "PMIX_SERVER_ATTRIBUTES", .string = "pmix.srvr.attrs", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of functions, including \"all\"",
                               "when used in a query, indicates whether or not to",
                               "include attributes supported by the PMIx server",
                               "library", NULL}},

    {.name = "PMIX_HOST_ATTRIBUTES", .string = "pmix.host.attrs", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of functions, including \"all\"",
                               "when used in a query, indicates whether or not to",
                               "include attributes supported by the host environment", NULL}},

    {.name = "PMIX_TOOL_ATTRIBUTES", .string = "pmix.tool.attrs", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of functions, including \"all\"",
                               "when used in a query, indicates whether or not to",
                               "include attributes supported by the PMIx tool library", NULL}},

    {.name = "PMIX_QUERY_SUPPORTED_QUALIFIERS", .string = "pmix.qry.quals", .type = PMIX_BOOL,
     .description = (char *[]){"return comma-delimited list of qualifiers supported",
                               "by a query on the provided key, instead of actually",
                               "performing the query on the key.", NULL}},

    {.name = "PMIX_SESSION_INFO", .string = "pmix.ssn.info", .type = PMIX_BOOL,
     .description = (char *[]){"Return information about the specified session. If",
                               "information about a session other than the one",
                               "containing the requesting process is desired, then",
                               "the attribute array must contain a PMIX_SESSION_ID",
                               "attribute identifying the desired target.", NULL}},

    {.name = "PMIX_JOB_INFO", .string = "pmix.job.info", .type = PMIX_BOOL,
     .description = (char *[]){"Return information about the specified job or",
                               "namespace. If information about a job or namespace",
                               "other than the one containing the requesting process",
                               "is desired, then the attribute array must contain a",
                               "PMIX_JOBID or PMIX_NSPACE attribute identifying the",
                               "desired target. Similarly, if information is",
                               "requested about a job or namespace in a session other",
                               "than the one containing the requesting process, then",
                               "an attribute identifying the target session must be",
                               "provided.", NULL}},

    {.name = "PMIX_APP_INFO", .string = "pmix.app.info", .type = PMIX_BOOL,
     .description = (char *[]){"Return information about the specified application.",
                               "If information about an application other than the",
                               "one containing the requesting process is desired,",
                               "then the attribute array must contain a PMIX_APPNUM",
                               "attribute identifying the desired target. Similarly,",
                               "if information is requested about an application in a",
                               "job or session other than the one containing the",
                               "requesting process, then attributes identifying the",
                               "target job and/or session must be provided.", NULL}},

    {.name = "PMIX_NODE_INFO", .string = "pmix.node.info", .type = PMIX_BOOL,
     .description = (char *[]){"Return information about the specified node. If",
                               "information about a node other than the one",
                               "containing the requesting process is desired, then",
                               "the attribute array must contain either the",
                               "PMIX_NODEID or PMIX_HOSTNAME attribute identifying",
                               "the desired target.", NULL}},

    {.name = "PMIX_SESSION_INFO_ARRAY", .string = "pmix.ssn.arr", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Provide an array of pmix_info_t containing",
                               "session-level information. The PMIX_SESSION_ID",
                               "attribute is required to be included in the array.", NULL}},

    {.name = "PMIX_JOB_INFO_ARRAY", .string = "pmix.job.arr", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Provide an array of pmix_info_t containing job-level",
                               "information. Information is registered one job (aka",
                               "namespace) at a time via the",
                               "PMIx_server_register_nspace API. Thus, there is no",
                               "requirement that the array contain either the",
                               "PMIX_NSPACE or PMIX_JOBID attributes, though either",
                               "or both of them may be included.", NULL}},

    {.name = "PMIX_APP_INFO_ARRAY", .string = "pmix.app.arr", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Provide an array of pmix_info_t containing app-level",
                               "information. The PMIX_NSPACE or PMIX_JOBID attributes",
                               "of the job containing the appplication, plus its",
                               "PMIX_APPNUM attribute, are required to be included in",
                               "the array.", NULL}},

    {.name = "PMIX_PROC_INFO_ARRAY", .string = "pmix.pdata", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Provide an array of pmix_info_t containing",
                               "process-realm information. The PMIX_RANK and",
                               "PMIX_NSPACE attributes, or the PMIX_PROCID attribute,",
                               "are required to be included in the array when the",
                               "array is not included as part of a call to",
                               "PMIx_server_register_nspace - i.e., when the job",
                               "containing the process is ambiguous. All three may be",
                               "included if desired. When the array is included in",
                               "some broader structure that identifies the job, then",
                               "only the PMIX_RANK or the PMIX_PROCID attribute must",
                               "be included (the others are optional).", NULL}},

    {.name = "PMIX_NODE_INFO_ARRAY", .string = "pmix.node.arr", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Provide an array of pmix_info_t containing node-level",
                               "information. At a minimum, either the PMIX_NODEID or",
                               "PMIX_HOSTNAME attribute is required to be included in",
                               "the array, though both may be included.", NULL}},

    {.name = "PMIX_SERVER_INFO_ARRAY", .string = "pmix.srv.arr", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of data on a given server, starting with its",
                               "nspace", NULL}},

    {.name = "PMIX_LOG_SOURCE", .string = "pmix.log.source", .type = PMIX_PROC,
     .description = (char *[]){"ID of source of the log request", NULL}},

    {.name = "PMIX_LOG_STDERR", .string = "pmix.log.stderr", .type = PMIX_STRING,
     .description = (char *[]){"log string to stderr", NULL}},

    {.name = "PMIX_LOG_STDOUT", .string = "pmix.log.stdout", .type = PMIX_STRING,
     .description = (char *[]){"log string to stdout", NULL}},

    {.name = "PMIX_LOG_SYSLOG", .string = "pmix.log.syslog", .type = PMIX_STRING,
     .description = (char *[]){"log message to syslog - defaults to ERROR priority.",
                               "Will log to global syslog if available, otherwise to",
                               "local syslog", NULL}},

    {.name = "PMIX_LOG_LOCAL_SYSLOG", .string = "pmix.log.lsys", .type = PMIX_STRING,
     .description = (char *[]){"log msg to local syslog - defaults to ERROR priority", NULL}},

    {.name = "PMIX_LOG_GLOBAL_SYSLOG", .string = "pmix.log.gsys", .type = PMIX_STRING,
     .description = (char *[]){"forward data to system \"master\" and log msg to that",
                               "syslog", NULL}},

    {.name = "PMIX_LOG_SYSLOG_PRI", .string = "pmix.log.syspri", .type = PMIX_INT,
     .description = (char *[]){"syslog priority level", NULL}},

    {.name = "PMIX_LOG_TIMESTAMP", .string = "pmix.log.tstmp", .type = PMIX_TIME,
     .description = (char *[]){"timestamp for log report", NULL}},

    {.name = "PMIX_LOG_GENERATE_TIMESTAMP", .string = "pmix.log.gtstmp", .type = PMIX_BOOL,
     .description = (char *[]){"generate timestamp for log", NULL}},

    {.name = "PMIX_LOG_TAG_OUTPUT", .string = "pmix.log.tag", .type = PMIX_BOOL,
     .description = (char *[]){"label the output stream with the channel name (e.g.,",
                               "\"stdout\")", NULL}},

    {.name = "PMIX_LOG_TIMESTAMP_OUTPUT", .string = "pmix.log.tsout", .type = PMIX_BOOL,
     .description = (char *[]){"print timestamp in output string", NULL}},

    {.name = "PMIX_LOG_XML_OUTPUT", .string = "pmix.log.xml", .type = PMIX_BOOL,
     .description = (char *[]){"print the output stream in xml format", NULL}},

    {.name = "PMIX_LOG_ONCE", .string = "pmix.log.once", .type = PMIX_BOOL,
     .description = (char *[]){"only log this once with whichever channel can first",
                               "support it", NULL}},

    {.name = "PMIX_LOG_MSG", .string = "pmix.log.msg", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"message blob to be sent somewhere", NULL}},

    {.name = "PMIX_LOG_EMAIL", .string = "pmix.log.email", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"log via email based on array of pmix_info_t",
                               "containing directives", NULL}},

    {.name = "PMIX_LOG_EMAIL_ADDR", .string = "pmix.log.emaddr", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of email addresses that are to",
                               "recv msg", NULL}},

    {.name = "PMIX_LOG_EMAIL_SENDER_ADDR", .string = "pmix.log.emfaddr", .type = PMIX_STRING,
     .description = (char *[]){"return email address of sender", NULL}},

    {.name = "PMIX_LOG_EMAIL_SUBJECT", .string = "pmix.log.emsub", .type = PMIX_STRING,
     .description = (char *[]){"subject line for email", NULL}},

    {.name = "PMIX_LOG_EMAIL_MSG", .string = "pmix.log.emmsg", .type = PMIX_STRING,
     .description = (char *[]){"msg to be included in email", NULL}},

    {.name = "PMIX_LOG_EMAIL_SERVER", .string = "pmix.log.esrvr", .type = PMIX_STRING,
     .description = (char *[]){"hostname (or IP addr) of estmp server", NULL}},

    {.name = "PMIX_LOG_EMAIL_SRVR_PORT", .string = "pmix.log.esrvrprt", .type = PMIX_INT32,
     .description = (char *[]){"port the email server is listening to", NULL}},

    {.name = "PMIX_LOG_GLOBAL_DATASTORE", .string = "pmix.log.gstore", .type = PMIX_BOOL,
     .description = (char *[]){"log the provided data to a global datastore", NULL}},

    {.name = "PMIX_LOG_JOB_RECORD", .string = "pmix.log.jrec", .type = PMIX_BOOL,
     .description = (char *[]){"log the provided information to the RM's job record", NULL}},

    {.name = "PMIX_LOG_PROC_TERMINATION", .string = "pmix.logproc", .type = PMIX_BOOL,
     .description = (char *[]){"Requests that the launcher log the",
                               "PMIX_EVENT_PROC_TERMINATED event whenever a process",
                               "either normally or abnormally terminates.", NULL}},

    {.name = "PMIX_LOG_PROC_ABNORMAL_TERMINATION", .string = "pmix.logabproc", .type = PMIX_BOOL,
     .description = (char *[]){"Requests that the launcher log the",
                               "PMIX_EVENT_PROC_TERMINATED event only when a process",
                               "abnormally terminates.", NULL}},

    {.name = "PMIX_LOG_JOB_EVENTS", .string = "pmix.log.jev", .type = PMIX_BOOL,
     .description = (char *[]){"Requests that the launcher log the",
                               "PMIX_EVENT_JOB_START, PMIX_LAUNCH_COMPLETE, and",
                               "PMIX_EVENT_JOB_END events using PMIx_Log", NULL}},

    {.name = "PMIX_LOG_COMPLETION", .string = "pmix.logcomp", .type = PMIX_BOOL,
     .description = (char *[]){"Requests that the launcher log the PMIX_EVENT_JOB_END",
                               "event for normal or abnormal termination of the",
                               "spawned job using PMIx_Log. The event shall include",
                               "the returned status code (PMIX_JOB_TERM_STATUS) for",
                               "the corresponding job; the identity (PMIX_PROCID) and",
                               "exit status (PMIX_EXIT_CODE) of the first failed",
                               "process, if applicable; and a PMIX_EVENT_TIMESTAMP",
                               "indicating the time the termination occurred.", NULL}},

    {.name = "PMIX_DEBUG_STOP_ON_EXEC", .string = "pmix.dbg.exec", .type = PMIX_BOOL,
     .description = (char *[]){"job is being spawned under debugger - instruct it to",
                               "pause on start", NULL}},

    {.name = "PMIX_DEBUG_STOP_IN_INIT", .string = "pmix.dbg.init", .type = PMIX_BOOL,
     .description = (char *[]){"instruct job to stop during PMIx init", NULL}},

    {.name = "PMIX_DEBUG_WAIT_FOR_NOTIFY", .string = "pmix.dbg.notify", .type = PMIX_BOOL,
     .description = (char *[]){"block at desired point until receiving debugger",
                               "release notification", NULL}},

    {.name = "PMIX_DEBUG_TARGET", .string = "pmix.dbg.tgt", .type = PMIX_PROC,
     .description = (char *[]){"Identifier of proc(s) to be debugged", NULL}},

    {.name = "PMIX_DEBUG_DAEMONS_PER_PROC", .string = "pmix.dbg.dpproc", .type = PMIX_UINT16,
     .description = (char *[]){"Number of debugger daemons to be spawned per",
                               "application process. The launcher is to pass the",
                               "identifier of the namespace to be debugged by",
                               "including the PMIX_DEBUG_TARGET attribute in the",
                               "daemon's job-level information. The debugger daemons",
                               "spawned on a given node are responsible for",
                               "self-determining their specific target process(es) -",
                               "e.g., by referencing their own PMIX_LOCAL_RANK in the",
                               "daemon debugger job versus the corresponding",
                               "PMIX_LOCAL_RANK of the target processes on the node.", NULL}},

    {.name = "PMIX_DEBUG_DAEMONS_PER_NODE", .string = "pmix.dbg.dpnd", .type = PMIX_UINT16,
     .description = (char *[]){"Number of debugger daemons to be spawned on each node",
                               "where the target job is executing. The launcher is to",
                               "pass the identifier of the namespace to be debugged",
                               "by including the PMIX_DEBUG_TARGET attribute in the",
                               "daemon's job-level information. The debugger daemons",
                               "spawned on a given node are responsible for",
                               "self-determining their specific target process(es) -",
                               "e.g., by referencing their own PMIX_LOCAL_RANK in the",
                               "daemon debugger job versus the corresponding",
                               "PMIX_LOCAL_RANK of the target processes on the node.", NULL}},

    {.name = "PMIX_RM_NAME", .string = "pmix.rm.name", .type = PMIX_STRING,
     .description = (char *[]){"string name of the resource manager", NULL}},

    {.name = "PMIX_RM_VERSION", .string = "pmix.rm.version", .type = PMIX_STRING,
     .description = (char *[]){"RM version string", NULL}},

    {.name = "PMIX_SET_ENVAR", .string = "pmix.envar.set", .type = PMIX_ENVAR,
     .description = (char *[]){"set the envar to the given value, overwriting any",
                               "pre-existing one", NULL}},

    {.name = "PMIX_ADD_ENVAR", .string = "pmix.envar.add", .type = PMIX_ENVAR,
     .description = (char *[]){"add envar, but do not overwrite any existing one", NULL}},

    {.name = "PMIX_UNSET_ENVAR", .string = "pmix.envar.unset", .type = PMIX_STRING,
     .description = (char *[]){"unset the envar, if present", NULL}},

    {.name = "PMIX_PREPEND_ENVAR", .string = "pmix.envar.prepnd", .type = PMIX_ENVAR,
     .description = (char *[]){"prepend the given value to the specified envar using",
                               "the separator character, creating the envar if it",
                               "doesn't already exist", NULL}},

    {.name = "PMIX_APPEND_ENVAR", .string = "pmix.envar.appnd", .type = PMIX_ENVAR,
     .description = (char *[]){"append the given value to the specified envar using",
                               "the separator character, creating the envar if it",
                               "doesn't already exist", NULL}},

    {.name = "PMIX_FIRST_ENVAR", .string = "pmix.envar.first", .type = PMIX_ENVAR,
     .description = (char *[]){"ensure the given value appears first in the specified",
                               "envar using the separator character, creating the",
                               "envar if it doesn't already exist", NULL}},

    {.name = "PMIX_ALLOC_REQ_ID", .string = "pmix.alloc.reqid", .type = PMIX_STRING,
     .description = (char *[]){"User-provided string identifier for this allocation",
                               "request which can later be used to query status of",
                               "the request.", NULL}},

    {.name = "PMIX_ALLOC_ID", .string = "pmix.alloc.id", .type = PMIX_STRING,
     .description = (char *[]){"A string identifier (provided by the host",
                               "environment) for the resulting allocation which can",
                               "later be used to reference the allocated resources",
                               "in, for example, a call to PMIx_Spawn", NULL}},

    {.name = "PMIX_ALLOC_NUM_NODES", .string = "pmix.alloc.nnodes", .type = PMIX_UINT64,
     .description = (char *[]){"number of nodes", NULL}},

    {.name = "PMIX_ALLOC_NODE_LIST", .string = "pmix.alloc.nlist", .type = PMIX_STRING,
     .description = (char *[]){"regex of specific nodes", NULL}},

    {.name = "PMIX_ALLOC_NUM_CPUS", .string = "pmix.alloc.ncpus", .type = PMIX_UINT64,
     .description = (char *[]){"number of cpus", NULL}},

    {.name = "PMIX_ALLOC_NUM_CPU_LIST", .string = "pmix.alloc.ncpulist", .type = PMIX_STRING,
     .description = (char *[]){"regex of #cpus for each node", NULL}},

    {.name = "PMIX_ALLOC_CPU_LIST", .string = "pmix.alloc.cpulist", .type = PMIX_STRING,
     .description = (char *[]){"regex of specific cpus indicating the cpus involved.", NULL}},

    {.name = "PMIX_ALLOC_MEM_SIZE", .string = "pmix.alloc.msize", .type = PMIX_FLOAT,
     .description = (char *[]){"number of Mbytes", NULL}},

    {.name = "PMIX_ALLOC_FABRIC", .string = "pmix.alloc.net", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Array of pmix_info_t describing fabric resource",
                               "request. This must include at least: *",
                               "PMIX_ALLOC_FABRIC_ID * PMIX_ALLOC_FABRIC_TYPE *",
                               "PMIX_ALLOC_FABRIC_ENDPTS plus whatever other",
                               "descriptors are desired", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_ID", .string = "pmix.alloc.netid", .type = PMIX_STRING,
     .description = (char *[]){"key to be used when accessing this requested fabric",
                               "allocation. The allocation will be returned/stored as",
                               "a pmix_data_array_t of pmix_info_t indexed by this",
                               "key and containing at least one entry with the same",
                               "key and the allocated resource description. The type",
                               "of the included value depends upon the fabric",
                               "support. For example, a TCP allocation might consist",
                               "of a comma-delimited string of socket ranges such as",
                               "\"32000-32100,33005,38123-38146\". Additional entries",
                               "will consist of any provided resource request",
                               "directives, along with their assigned values.",
                               "Examples include: * PMIX_ALLOC_FABRIC_TYPE - the type",
                               "of resources provided * PMIX_ALLOC_FABRIC_PLANE - if",
                               "applicable, what plane the resources were assigned",
                               "from * PMIX_ALLOC_FABRIC_QOS - the assigned QoS *",
                               "PMIX_ALLOC_BANDWIDTH - the allocated bandwidth *",
                               "PMIX_ALLOC_FABRIC_SEC_KEY - a security key for the",
                               "requested fabric allocation NOTE: the assigned values",
                               "may differ from those requested, especially if the",
                               "\"required\" flag was not set in the request", NULL}},

    {.name = "PMIX_ALLOC_BANDWIDTH", .string = "pmix.alloc.bw", .type = PMIX_FLOAT,
     .description = (char *[]){"Mbits/sec", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_QOS", .string = "pmix.alloc.netqos", .type = PMIX_STRING,
     .description = (char *[]){"quality of service level", NULL}},

    {.name = "PMIX_ALLOC_TIME", .string = "pmix.alloc.time", .type = PMIX_UINT32,
     .description = (char *[]){"time in seconds that the allocation shall remain",
                               "valid", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_TYPE", .string = "pmix.alloc.nettype", .type = PMIX_STRING,
     .description = (char *[]){"type of desired transport (e.g., tcp, udp)", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_PLANE", .string = "pmix.alloc.netplane", .type = PMIX_STRING,
     .description = (char *[]){"id string for the NIC (aka plane) to be used for this",
                               "allocation (e.g., CIDR for Ethernet)", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_ENDPTS", .string = "pmix.alloc.endpts", .type = PMIX_SIZE,
     .description = (char *[]){"number of endpoints to allocate per process", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_ENDPTS_NODE", .string = "pmix.alloc.endpts.nd", .type = PMIX_SIZE,
     .description = (char *[]){"number of endpoints to allocate per node", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_SEC_KEY", .string = "pmix.alloc.nsec", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"fabric security key", NULL}},

    {.name = "PMIX_ALLOC_QUEUE", .string = "pmix.alloc.queue", .type = PMIX_STRING,
     .description = (char *[]){"name of queue being referenced", NULL}},

    {.name = "PMIX_JOB_CTRL_ID", .string = "pmix.jctrl.id", .type = PMIX_STRING,
     .description = (char *[]){"provide a string identifier for this request", NULL}},

    {.name = "PMIX_JOB_CTRL_PAUSE", .string = "pmix.jctrl.pause", .type = PMIX_BOOL,
     .description = (char *[]){"pause the specified processes", NULL}},

    {.name = "PMIX_JOB_CTRL_RESUME", .string = "pmix.jctrl.resume", .type = PMIX_BOOL,
     .description = (char *[]){"\"un-pause\" the specified processes", NULL}},

    {.name = "PMIX_JOB_CTRL_CANCEL", .string = "pmix.jctrl.cancel", .type = PMIX_STRING,
     .description = (char *[]){"cancel the specified request (NULL => cancel all",
                               "requests from this requestor)", NULL}},

    {.name = "PMIX_JOB_CTRL_KILL", .string = "pmix.jctrl.kill", .type = PMIX_BOOL,
     .description = (char *[]){"forcibly terminate the specified processes and",
                               "cleanup", NULL}},

    {.name = "PMIX_JOB_CTRL_RESTART", .string = "pmix.jctrl.restart", .type = PMIX_STRING,
     .description = (char *[]){"restart the specified processes using the given",
                               "checkpoint ID", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT", .string = "pmix.jctrl.ckpt", .type = PMIX_STRING,
     .description = (char *[]){"checkpoint the specified processes and assign the",
                               "given ID to it", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT_EVENT", .string = "pmix.jctrl.ckptev", .type = PMIX_BOOL,
     .description = (char *[]){"use event notification to trigger process checkpoint", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT_SIGNAL", .string = "pmix.jctrl.ckptsig", .type = PMIX_INT,
     .description = (char *[]){"use the given signal to trigger process checkpoint", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT_TIMEOUT", .string = "pmix.jctrl.ckptsig", .type = PMIX_INT,
     .description = (char *[]){"time in seconds to wait for checkpoint to complete", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT_METHOD", .string = "pmix.jctrl.ckmethod", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_info_t declaring each method and value",
                               "supported by this application", NULL}},

    {.name = "PMIX_JOB_CTRL_SIGNAL", .string = "pmix.jctrl.sig", .type = PMIX_INT,
     .description = (char *[]){"send given signal to specified processes", NULL}},

    {.name = "PMIX_JOB_CTRL_PROVISION", .string = "pmix.jctrl.pvn", .type = PMIX_STRING,
     .description = (char *[]){"regex identifying nodes that are to be provisioned", NULL}},

    {.name = "PMIX_JOB_CTRL_PROVISION_IMAGE", .string = "pmix.jctrl.pvnimg", .type = PMIX_STRING,
     .description = (char *[]){"name of the image that is to be provisioned", NULL}},

    {.name = "PMIX_JOB_CTRL_PREEMPTIBLE", .string = "pmix.jctrl.preempt", .type = PMIX_BOOL,
     .description = (char *[]){"job can be pre-empted", NULL}},

    {.name = "PMIX_JOB_CTRL_TERMINATE", .string = "pmix.jctrl.term", .type = PMIX_BOOL,
     .description = (char *[]){"politely terminate the specified procs", NULL}},

    {.name = "PMIX_REGISTER_CLEANUP", .string = "pmix.reg.cleanup", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of files to be removed upon",
                               "process termination", NULL}},

    {.name = "PMIX_REGISTER_CLEANUP_DIR", .string = "pmix.reg.cleanupdir", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of directories to be removed",
                               "upon process termination", NULL}},

    {.name = "PMIX_CLEANUP_RECURSIVE", .string = "pmix.clnup.recurse", .type = PMIX_BOOL,
     .description = (char *[]){"recursively cleanup all subdirectories under the",
                               "specified one(s)", NULL}},

    {.name = "PMIX_CLEANUP_EMPTY", .string = "pmix.clnup.empty", .type = PMIX_BOOL,
     .description = (char *[]){"only remove empty subdirectories", NULL}},

    {.name = "PMIX_CLEANUP_IGNORE", .string = "pmix.clnup.ignore", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of filenames that are not to be",
                               "removed", NULL}},

    {.name = "PMIX_CLEANUP_LEAVE_TOPDIR", .string = "pmix.clnup.lvtop", .type = PMIX_BOOL,
     .description = (char *[]){"when recursively cleaning subdirs, do not remove the",
                               "top-level directory (the one given in the cleanup",
                               "request)", NULL}},

    {.name = "PMIX_MONITOR_ID", .string = "pmix.monitor.id", .type = PMIX_STRING,
     .description = (char *[]){"provide a string identifier for this request", NULL}},

    {.name = "PMIX_MONITOR_CANCEL", .string = "pmix.monitor.cancel", .type = PMIX_STRING,
     .description = (char *[]){"identifier to be canceled (NULL = cancel all",
                               "monitoring for this process)", NULL}},

    {.name = "PMIX_MONITOR_APP_CONTROL", .string = "pmix.monitor.appctrl", .type = PMIX_BOOL,
     .description = (char *[]){"the application desires to control the response to a",
                               "monitoring event", NULL}},

    {.name = "PMIX_MONITOR_HEARTBEAT", .string = "pmix.monitor.mbeat", .type = PMIX_BOOL,
     .description = (char *[]){"register to have the server monitor the requestor for",
                               "heartbeats", NULL}},

    {.name = "PMIX_SEND_HEARTBEAT", .string = "pmix.monitor.beat", .type = PMIX_BOOL,
     .description = (char *[]){"send heartbeat to local server", NULL}},

    {.name = "PMIX_MONITOR_HEARTBEAT_TIME", .string = "pmix.monitor.btime", .type = PMIX_UINT32,
     .description = (char *[]){"time in seconds before declaring heartbeat missed", NULL}},

    {.name = "PMIX_MONITOR_HEARTBEAT_DROPS", .string = "pmix.monitor.bdrop", .type = PMIX_UINT32,
     .description = (char *[]){"number of heartbeats that can be missed before",
                               "generating the event", NULL}},

    {.name = "PMIX_MONITOR_FILE", .string = "pmix.monitor.fmon", .type = PMIX_STRING,
     .description = (char *[]){"register to monitor file for signs of life", NULL}},

    {.name = "PMIX_MONITOR_FILE_SIZE", .string = "pmix.monitor.fsize", .type = PMIX_BOOL,
     .description = (char *[]){"monitor size of given file is growing to determine",
                               "app is running", NULL}},

    {.name = "PMIX_MONITOR_FILE_ACCESS", .string = "pmix.monitor.faccess", .type = PMIX_STRING,
     .description = (char *[]){"monitor time since last access of given file to",
                               "determine app is running", NULL}},

    {.name = "PMIX_MONITOR_FILE_MODIFY", .string = "pmix.monitor.fmod", .type = PMIX_STRING,
     .description = (char *[]){"monitor time since last modified of given file to",
                               "determine app is running", NULL}},

    {.name = "PMIX_MONITOR_FILE_CHECK_TIME", .string = "pmix.monitor.ftime", .type = PMIX_UINT32,
     .description = (char *[]){"time in seconds between checking file", NULL}},

    {.name = "PMIX_MONITOR_FILE_DROPS", .string = "pmix.monitor.fdrop", .type = PMIX_UINT32,
     .description = (char *[]){"number of file checks that can be missed before",
                               "generating the event", NULL}},

    {.name = "PMIX_CRED_TYPE", .string = "pmix.sec.ctype", .type = PMIX_STRING,
     .description = (char *[]){"when passed in PMIx_Get_credential, a prioritized,",
                               "comma-delimited list of desired credential types for",
                               "use in environments where multiple authentication",
                               "mechanisms may be available. When returned in a",
                               "callback function, a string identifier of the",
                               "credential type", NULL}},

    {.name = "PMIX_CRYPTO_KEY", .string = "pmix.sec.key", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"blob containing crypto key", NULL}},

    {.name = "PMIX_IOF_CACHE_SIZE", .string = "pmix.iof.csize", .type = PMIX_UINT32,
     .description = (char *[]){"requested size of the server cache in bytes for each",
                               "specified channel. By default, the server is allowed",
                               "(but not required) to drop all bytes received beyond",
                               "the max size", NULL}},

    {.name = "PMIX_IOF_DROP_OLDEST", .string = "pmix.iof.old", .type = PMIX_BOOL,
     .description = (char *[]){"in an overflow situation, drop the oldest bytes to",
                               "make room in the cache", NULL}},

    {.name = "PMIX_IOF_DROP_NEWEST", .string = "pmix.iof.new", .type = PMIX_BOOL,
     .description = (char *[]){"in an overflow situation, drop any new bytes received",
                               "until room becomes available in the cache (default)", NULL}},

    {.name = "PMIX_IOF_BUFFERING_SIZE", .string = "pmix.iof.bsize", .type = PMIX_UINT32,
     .description = (char *[]){"basically controls grouping of IO on the specified",
                               "channel(s) to avoid being called every time a bit of",
                               "IO arrives. The library will execute the callback",
                               "whenever the specified number of bytes becomes",
                               "available. Any remaining buffered data will be",
                               "\"flushed\" upon call to deregister the respective",
                               "channel", NULL}},

    {.name = "PMIX_IOF_BUFFERING_TIME", .string = "pmix.iof.btime", .type = PMIX_UINT32,
     .description = (char *[]){"max time in seconds to buffer IO before delivering",
                               "it. Used in conjunction with buffering size, this",
                               "prevents IO from being held indefinitely while",
                               "waiting for another payload to arrive", NULL}},

    {.name = "PMIX_IOF_COMPLETE", .string = "pmix.iof.cmp", .type = PMIX_BOOL,
     .description = (char *[]){"indicates whether or not the specified IO channel has",
                               "been closed by the source", NULL}},

    {.name = "PMIX_IOF_PUSH_STDIN", .string = "pmix.iof.stdin", .type = PMIX_BOOL,
     .description = (char *[]){"Used by a tool to request that the PMIx library",
                               "collect the tool's stdin and forward it to the procs",
                               "specified in the PMIx_IOF_push call", NULL}},

    {.name = "PMIX_IOF_TAG_OUTPUT", .string = "pmix.iof.tag", .type = PMIX_BOOL,
     .description = (char *[]){"Tag output with the channel it comes from", NULL}},

    {.name = "PMIX_IOF_TIMESTAMP_OUTPUT", .string = "pmix.iof.ts", .type = PMIX_BOOL,
     .description = (char *[]){"Timestamp output", NULL}},

    {.name = "PMIX_IOF_XML_OUTPUT", .string = "pmix.iof.xml", .type = PMIX_BOOL,
     .description = (char *[]){"Format output in XML", NULL}},

    {.name = "PMIX_IOF_COPY", .string = "pmix.iof.cpy", .type = PMIX_BOOL,
     .description = (char *[]){"Requests that the host environment deliver a copy of",
                               "the specified output stream(s) to the tool, letting",
                               "the stream(s) continue to also be delivered to the",
                               "default location. This allows the tool to tap into",
                               "the output stream(s) without redirecting it from its",
                               "current final destination.", NULL}},

    {.name = "PMIX_IOF_REDIRECT", .string = "pmix.iof.redir", .type = PMIX_BOOL,
     .description = (char *[]){"Requests that the host environment intercept the",
                               "specified output stream(s) and deliver it to the",
                               "requesting tool instead of its current final",
                               "destination. This might be used, for example, during",
                               "a debugging procedure to avoid injection of",
                               "debugger-related output into the application’s",
                               "results file. The original output stream(s)",
                               "destination is restored upon termination of the tool.", NULL}},

    {.name = "PMIX_SETUP_APP_ENVARS", .string = "pmix.setup.env", .type = PMIX_BOOL,
     .description = (char *[]){"harvest and include relevant envars", NULL}},

    {.name = "PMIX_SETUP_APP_NONENVARS", .string = "pmix.setup.nenv", .type = PMIX_BOOL,
     .description = (char *[]){"include all non-envar data", NULL}},

    {.name = "PMIX_SETUP_APP_ALL", .string = "pmix.setup.all", .type = PMIX_BOOL,
     .description = (char *[]){"include all relevant data", NULL}},

    {.name = "PMIX_GROUP_ID", .string = "pmix.grp.id", .type = PMIX_STRING,
     .description = (char *[]){"user-provided group identifier", NULL}},

    {.name = "PMIX_GROUP_LEADER", .string = "pmix.grp.ldr", .type = PMIX_BOOL,
     .description = (char *[]){"this process is the leader of the group", NULL}},

    {.name = "PMIX_GROUP_OPTIONAL", .string = "pmix.grp.opt", .type = PMIX_BOOL,
     .description = (char *[]){"participation is optional - do not return an error if",
                               "any of the specified processes terminate without",
                               "having joined. The default is false", NULL}},

    {.name = "PMIX_GROUP_NOTIFY_TERMINATION", .string = "pmix.grp.notterm", .type = PMIX_BOOL,
     .description = (char *[]){"notify remaining members when another member",
                               "terminates without first leaving the group. The",
                               "default is false", NULL}},

    {.name = "PMIX_GROUP_FT_COLLECTIVE", .string = "pmix.grp.ftcoll", .type = PMIX_BOOL,
     .description = (char *[]){"adjust internal tracking for terminated processes.",
                               "Default is false", NULL}},

    {.name = "PMIX_GROUP_MEMBERSHIP", .string = "pmix.grp.mbrs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of group member ID's", NULL}},

    {.name = "PMIX_GROUP_ASSIGN_CONTEXT_ID", .string = "pmix.grp.actxid", .type = PMIX_BOOL,
     .description = (char *[]){"request that the RM assign a unique numerical",
                               "(size_t) ID to this group", NULL}},

    {.name = "PMIX_GROUP_CONTEXT_ID", .string = "pmix.grp.ctxid", .type = PMIX_SIZE,
     .description = (char *[]){"context ID assigned to group", NULL}},

    {.name = "PMIX_GROUP_LOCAL_ONLY", .string = "pmix.grp.lcl", .type = PMIX_BOOL,
     .description = (char *[]){"group operation only involves local procs", NULL}},

    {.name = "PMIX_GROUP_ENDPT_DATA", .string = "pmix.grp.endpt", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"data collected to be shared during construction", NULL}},

    {.name = "PMIX_GROUP_NAMES", .string = "pmix.pgrp.nm", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Returns an array of string names of the process",
                               "groups in which the given process is a member.", NULL}},

    {.name = "PMIX_QUERY_STORAGE_LIST", .string = "pmix.strg.list", .type = PMIX_STRING,
     .description = (char *[]){"return comma-delimited list of identifiers for all",
                               "available storage systems", NULL}},

    {.name = "PMIX_STORAGE_CAPACITY_LIMIT", .string = "pmix.strg.cap", .type = PMIX_UINT64,
     .description = (char *[]){"return overall capacity (in Megabytes[base2]) of",
                               "specified storage system", NULL}},

    {.name = "PMIX_STORAGE_CAPACITY_FREE", .string = "pmix.strg.free", .type = PMIX_UINT64,
     .description = (char *[]){"return free capacity (in Megabytes[base2]) of",
                               "specified storage system", NULL}},

    {.name = "PMIX_STORAGE_CAPACITY_AVAIL", .string = "pmix.strg.avail", .type = PMIX_UINT64,
     .description = (char *[]){"return capacity (in Megabytes[[base2]]) of specified",
                               "storage system that is available for use by the",
                               "calling program", NULL}},

    {.name = "PMIX_STORAGE_OBJECT_LIMIT", .string = "pmix.strg.obj", .type = PMIX_UINT64,
     .description = (char *[]){"return overall limit on number of objects (e.g.,",
                               "inodes) of specified storage system", NULL}},

    {.name = "PMIX_STORAGE_OBJECTS_FREE", .string = "pmix.strg.objf", .type = PMIX_UINT64,
     .description = (char *[]){"return number of free objects (e.g., inodes) of",
                               "specified storage system", NULL}},

    {.name = "PMIX_STORAGE_OBJECTS_AVAIL", .string = "pmix.strg.obja", .type = PMIX_UINT64,
     .description = (char *[]){"return number of objects (e.g., inodes) of specified",
                               "storage system that are available for use by the",
                               "calling program", NULL}},

    {.name = "PMIX_STORAGE_BW", .string = "pmix.strg.bw", .type = PMIX_FLOAT,
     .description = (char *[]){"return overall bandwidth (in Megabytes[base2]/sec) of",
                               "specified storage system", NULL}},

    {.name = "PMIX_STORAGE_AVAIL_BW", .string = "pmix.strg.availbw", .type = PMIX_FLOAT,
     .description = (char *[]){"return overall bandwidth (in Megabytes[base2]/sec) of",
                               "specified storage system that is available for use by",
                               "the calling program", NULL}},

    {.name = "PMIX_STORAGE_ID", .string = "pmix.strg.id", .type = PMIX_STRING,
     .description = (char *[]){"identifier of the storage system being referenced", NULL}},

    {.name = "PMIX_STORAGE_PATH", .string = "pmix.strg.path", .type = PMIX_STRING,
     .description = (char *[]){"Mount point corresponding to a specified storage ID", NULL}},

    {.name = "PMIX_STORAGE_TYPE", .string = "pmix.strg.type", .type = PMIX_STRING,
     .description = (char *[]){"Qualifier indicating the type of storage being",
                               "referenced by a query (e.g., lustre, gpfs, online,",
                               "fabric-attached, ...)", NULL}},

    {.name = "PMIX_FABRIC_COST_MATRIX", .string = "pmix.fab.cm", .type = PMIX_POINTER,
     .description = (char *[]){"Pointer to a two-dimensional array of point-to-point",
                               "relative communication costs expressed as uint16_t",
                               "values", NULL}},

    {.name = "PMIX_FABRIC_GROUPS", .string = "pmix.fab.grps", .type = PMIX_STRING,
     .description = (char *[]){"A string delineating the group membership of nodes in",
                               "the system, where each fabric group consists of the",
                               "group number followed by a colon and a",
                               "comma-delimited list of nodes in that group, with the",
                               "groups delimited by semi-colons (e.g.,",
                               "0:node000,node002,node004,node006;1:node001,node003,node005,node007)", NULL}},

    {.name = "PMIX_FABRIC_VENDOR", .string = "pmix.fab.vndr", .type = PMIX_STRING,
     .description = (char *[]){"Name of fabric vendor (e.g., Amazon, Mellanox, HPE,",
                               "Intel)", NULL}},

    {.name = "PMIX_FABRIC_IDENTIFIER", .string = "pmix.fab.id", .type = PMIX_STRING,
     .description = (char *[]){"An identifier for the fabric (e.g., MgmtEthernet,",
                               "Slingshot-11, OmniPath-1)", NULL}},

    {.name = "PMIX_FABRIC_INDEX", .string = "pmix.fab.idx", .type = PMIX_SIZE,
     .description = (char *[]){"The index of the fabric as returned in pmix_fabric_t", NULL}},

    {.name = "PMIX_FABRIC_COORDINATES", .string = "pmix.fab.coord", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Array of pmix_geometry_t fabric coordinates for",
                               "devices on the specified node. The array will contain",
                               "the coordinates of all devices on the node, including",
                               "values for all supported coordinate views. The",
                               "information for devices on the local node shall be",
                               "provided if the node is not specified in the request.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_VENDORID", .string = "pmix.fabdev.vendid", .type = PMIX_STRING,
     .description = (char *[]){"This is a vendor-provided identifier for the device",
                               "or product.", NULL}},

    {.name = "PMIX_FABRIC_NUM_DEVICES", .string = "pmix.fab.nverts", .type = PMIX_SIZE,
     .description = (char *[]){"Total number of fabric devices in the system -",
                               "corresponds to the number of rows or columns in the",
                               "cost matrix", NULL}},

    {.name = "PMIX_FABRIC_VIEW", .string = "pmix.fab.view", .type = PMIX_UINT8,
     .description = (char *[]){"Used purely as a qualifier to requests, specifies the",
                               "view type (e.g., local vs. physical) for the",
                               "requested information.", NULL}},

    {.name = "PMIX_FABRIC_DIMS", .string = "pmix.fab.dims", .type = PMIX_UINT32,
     .description = (char *[]){"Number of dimensions in the specified fabric",
                               "plane/view. If no plane is specified in a request,",
                               "then the dimensions of all planes in the overall",
                               "system will be returned as a pmix_data_array_t",
                               "containing an array of uint32_t values. Default is to",
                               "provide dimensions in logical view.", NULL}},

    {.name = "PMIX_FABRIC_PLANE", .string = "pmix.fab.plane", .type = PMIX_STRING,
     .description = (char *[]){"ID string of a fabric plane (e.g., CIDR for",
                               "Ethernet). When used as a modifier in a request for",
                               "information, specifies the plane whose information is",
                               "to be returned. When used directly as a key in a",
                               "request, returns a pmix_data_array_t of string",
                               "identifiers for all fabric planes in the overall",
                               "system.", NULL}},

    {.name = "PMIX_FABRIC_SWITCH", .string = "pmix.fab.switch", .type = PMIX_STRING,
     .description = (char *[]){"ID string of a fabric switch. When used as a modifier",
                               "in a request for information, specifies the switch",
                               "whose information is to be returned. When used",
                               "directly as a key in a request, returns a",
                               "pmix_data_array_t of string identifiers for all",
                               "fabric switches in the overall system.", NULL}},

    {.name = "PMIX_FABRIC_ENDPT", .string = "pmix.fab.endpt", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Fabric endpoints for a specified process. As multiple",
                               "endpoints may be assigned to a given process (e.g.,",
                               "in the case where multiple devices are associated",
                               "with a package to which the process is bound), the",
                               "returned values will be provided in a",
                               "pmix_data_array_t of pmix_endpoint_t elements.", NULL}},

    {.name = "PMIX_FABRIC_SHAPE", .string = "pmix.fab.shape", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"The size of each dimension in the specified fabric",
                               "plane/view, returned in a pmix_data_array_t",
                               "containing an array of uint32_t values. The size is",
                               "defined as the number of elements present in that",
                               "dimension - e.g., the number of devices in one",
                               "dimension of a physical view of a fabric plane. If no",
                               "plane is specified, then the shape of each plane in",
                               "the overall system will be returned in a",
                               "pmix_data_array_t array where each element is itself",
                               "a two-element array containing the PMIX_FABRIC_PLANE",
                               "followed by that plane's fabric shape. Default is to",
                               "provide the shape in logical view.", NULL}},

    {.name = "PMIX_FABRIC_SHAPE_STRING", .string = "pmix.fab.shapestr", .type = PMIX_STRING,
     .description = (char *[]){"Network shape expressed as a string (e.g.,",
                               "\"10x12x2\"). If no plane is specified, then the",
                               "shape of each plane in the overall system will be",
                               "returned in a pmix_data_array_t array where each",
                               "element is itself a two-element array containing the",
                               "PMIX_FABRIC_PLANE followed by that plane's fabric",
                               "shape string. Default is to provide the shape in",
                               "logical view.", NULL}},

    {.name = "PMIX_SWITCH_PEERS", .string = "pmix.speers", .type = PMIX_STRING,
     .description = (char *[]){"Peer ranks that share the same switch as the process",
                               "specified in the call to PMIx_Get. Returns a",
                               "pmix_data_array_t array of pmix_info_t results, each",
                               "element containing the PMIX_SWITCH_PEERS key with a",
                               "three-element pmix_data_array_t array of pmix_info_t",
                               "containing the PMIX_FABRIC_DEVICE_ID of the local",
                               "fabric device, the PMIX_FABRIC_SWITCH identifying the",
                               "switch to which it is connected, and a",
                               "comma-delimited string of peer ranks sharing the",
                               "switch to which that device is connected.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE", .string = "pmix.fabdev", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"An array of pmix_info_t describing a particular",
                               "fabric device. The first element in the array shall",
                               "be the PMIX_FABRIC_DEVICE_ID of the device", NULL}},

    {.name = "PMIX_FABRIC_DEVICES", .string = "pmix.fab.devs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Array of pmix_info_t containing information for all",
                               "devices on the specified node. Each element of the",
                               "array will contain a PMIX_FABRIC_DEVICE entry, which",
                               "in turn will contain an array of information on a",
                               "given device.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_NAME", .string = "pmix.fabdev.nm", .type = PMIX_STRING,
     .description = (char *[]){"The operating system name associated with the device.",
                               "This may be a logical fabric interface name (e.g.",
                               "eth0 or eno1) or an absolute filename.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_INDEX", .string = "pmix.fabdev.idx", .type = PMIX_UINT32,
     .description = (char *[]){"Index of the device within an associated",
                               "communication cost matrix.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_VENDOR", .string = "pmix.fabdev.vndr", .type = PMIX_STRING,
     .description = (char *[]){"Indicates the name of the vendor that distributes the",
                               "NIC.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_BUS_TYPE", .string = "pmix.fabdev.btyp", .type = PMIX_STRING,
     .description = (char *[]){"The type of bus to which the device is attached",
                               "(e.g., \"PCI\", \"GEN-Z\").", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_DRIVER", .string = "pmix.fabdev.driver", .type = PMIX_STRING,
     .description = (char *[]){"The name of the driver associated with the device", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_FIRMWARE", .string = "pmix.fabdev.fmwr", .type = PMIX_STRING,
     .description = (char *[]){"The device’s firmware version", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_ADDRESS", .string = "pmix.fabdev.addr", .type = PMIX_STRING,
     .description = (char *[]){"The primary link-level address associated with the",
                               "device, such as a MAC address. If multiple addresses",
                               "are available, only one will be reported.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_COORDINATES", .string = "pmix.fab.coord", .type = PMIX_GEOMETRY,
     .description = (char *[]){"The pmix_geometry_t fabric coordinates for the",
                               "device, including values for all supported coordinate",
                               "views.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_MTU", .string = "pmix.fabdev.mtu", .type = PMIX_SIZE,
     .description = (char *[]){"The maximum transfer unit of link level frames or",
                               "packets, in bytes.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_SPEED", .string = "pmix.fabdev.speed", .type = PMIX_SIZE,
     .description = (char *[]){"The active link data rate, given in bits per second.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_STATE", .string = "pmix.fabdev.state", .type = PMIX_LINK_STATE,
     .description = (char *[]){"The last available physical port state. Possible",
                               "values are PMIX_LINK_STATE_UNKNOWN, PMIX_LINK_DOWN,",
                               "and PMIX_LINK_UP, to indicate if the port state is",
                               "unknown or not applicable (unknown), inactive (down),",
                               "or active (up).", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_TYPE", .string = "pmix.fabdev.type", .type = PMIX_STRING,
     .description = (char *[]){"Specifies the type of fabric interface currently",
                               "active on the device, such as Ethernet or InfiniBand.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_PCI_DEVID", .string = "pmix.fabdev.pcidevid", .type = PMIX_STRING,
     .description = (char *[]){"A node-level unique identifier for a PCI device.",
                               "Provided only if the device is located on a \ac{PCI}",
                               "bus. The identifier is constructed as a four-part",
                               "tuple delimited by colons comprised of the \ac{PCI}",
                               "16-bit domain, 8-bit bus, 8-bit device, and 8-bit",
                               "function IDs, each expressed in zero-extended",
                               "hexadecimal form. Thus, an example identifier might",
                               "be \"abc1:0f:23:01\". The combination of node",
                               "identifier PMIX_HOSTNAME or PMIX_NODEID and",
                               "PMIX_FABRIC_DEVICE_PCI_DEVID shall be unique within",
                               "the system.", NULL}},

    {.name = "PMIX_DEVICE_DISTANCES", .string = "pmix.dev.dist", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Return an array of pmix_device_dist_t containing the",
                               "minimum and maximum distances of the given process",
                               "location to all devices of the specified type on the",
                               "local node.", NULL}},

    {.name = "PMIX_DEVICE_TYPE", .string = "pmix.dev.type", .type = PMIX_DEVTYPE,
     .description = (char *[]){"Bitmask specifying the type(s) of device(s) whose",
                               "information is being requested. Only used as a",
                               "directive/qualifier.", NULL}},

    {.name = "PMIX_DEVICE_ID", .string = "pmix.dev.id", .type = PMIX_STRING,
     .description = (char *[]){"System-wide UUID or node-local OS name of a",
                               "particular device.", NULL}},

    {.name = "PMIX_MAX_VALUE", .string = "pmix.descr.maxval", .type = PMIX_INT,
     .description = (char *[]){"Used in pmix_regattr_t to describe the maximum valid",
                               "value for the associated attribute.", NULL}},

    {.name = "PMIX_MIN_VALUE", .string = "pmix.descr.minval", .type = PMIX_INT,
     .description = (char *[]){"Used in pmix_regattr_t to describe the minimum valid",
                               "value for the associated attribute.", NULL}},

    {.name = "PMIX_ENUM_VALUE", .string = "pmix.descr.enum", .type = PMIX_STRING,
     .description = (char *[]){"Used in pmix_regattr_t to describe accepted values",
                               "for the associated attribute. Numerical values shall",
                               "be presented in a form convertible to the attribute's",
                               "declared data type. Named values (i.e., values",
                               "defined by constant names via a typical C-language",
                               "enum declaration) must be provided as their numerical",
                               "equivalent.", NULL}},
    {.name = "PMIX_TOPOLOGY", .string = "pmix.topo", .type = PMIX_POINTER,
     .description = (char *[]){"***** DEPRECATED ***** pointer to the PMIx client's",
                               "internal topology object", NULL}},

    {.name = "PMIX_DEBUG_JOB", .string = "pmix.dbg.job", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED ***** nspace of the job assigned to",
                               "this debugger to be debugged. Note that id's, pids,",
                               "and other info on the procs is available via a query",
                               "for the nspace's local or global proctable", NULL}},

    {.name = "PMIX_RECONNECT_SERVER", .string = "pmix.cnct.recon", .type = PMIX_BOOL,
     .description = (char *[]){"tool is requesting to change server connections", NULL}},

    {.name = "PMIX_ALLOC_NETWORK", .string = "pmix.alloc.net", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_ID", .string = "pmix.alloc.netid", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_QOS", .string = "pmix.alloc.netqos", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_TYPE", .string = "pmix.alloc.nettype", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_PLANE", .string = "pmix.alloc.netplane", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_ENDPTS", .string = "pmix.alloc.endpts", .type = PMIX_SIZE,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_ENDPTS_NODE", .string = "pmix.alloc.endpts.nd", .type = PMIX_SIZE,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_SEC_KEY", .string = "pmix.alloc.nsec", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_PROC_DATA", .string = "pmix.pdata", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"***** DEPRECATED ***** starts with rank, then",
                               "contains more data", NULL}},

    {.name = "PMIX_LOCALITY", .string = "pmix.loc", .type = PMIX_UINT16,
     .description = (char *[]){"***** DEPRECATED *****relative locality of two procs", NULL}},

    {.name = "PMIX_LOCAL_TOPO", .string = "pmix.ltopo", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****xml-representation of local",
                               "node topology", NULL}},

    {.name = "PMIX_TOPOLOGY_XML", .string = "pmix.topo.xml", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****XML-based description of",
                               "topology", NULL}},

    {.name = "PMIX_TOPOLOGY_FILE", .string = "pmix.topo.file", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****full path to file containing",
                               "XML topology description", NULL}},

    {.name = "PMIX_TOPOLOGY_SIGNATURE", .string = "pmix.toposig", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****topology signature string", NULL}},

    {.name = "PMIX_HWLOC_SHMEM_ADDR", .string = "pmix.hwlocaddr", .type = PMIX_SIZE,
     .description = (char *[]){"***** DEPRECATED *****address of HWLOC shared memory",
                               "segment", NULL}},

    {.name = "PMIX_HWLOC_SHMEM_SIZE", .string = "pmix.hwlocsize", .type = PMIX_SIZE,
     .description = (char *[]){"***** DEPRECATED *****size of HWLOC shared memory",
                               "segment", NULL}},

    {.name = "PMIX_HWLOC_SHMEM_FILE", .string = "pmix.hwlocfile", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****path to HWLOC shared memory",
                               "file", NULL}},

    {.name = "PMIX_HWLOC_XML_V1", .string = "pmix.hwlocxml1", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED ***** XML representation of local",
                               "topology using HWLOC v1.x format", NULL}},

    {.name = "PMIX_HWLOC_XML_V2", .string = "pmix.hwlocxml2", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED ***** XML representation of local",
                               "topology using HWLOC v2.x format", NULL}},

    {.name = "PMIX_HWLOC_SHARE_TOPO", .string = "pmix.hwlocsh", .type = PMIX_BOOL,
     .description = (char *[]){"***** DEPRECATED ***** Share the HWLOC topology via",
                               "shared memory", NULL}},

    {.name = "PMIX_HWLOC_HOLE_KIND", .string = "pmix.hwlocholek", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED ***** Kind of VM \"hole\" HWLOC",
                               "should use for shared memory", NULL}},

    {.name = "PMIX_DSTPATH", .string = "pmix.dstpath", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED ***** path to dstore files", NULL}},

    {.name = "PMIX_COLLECTIVE_ALGO", .string = "pmix.calgo", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED ***** comma-delimited list of",
                               "algorithms to use for collective", NULL}},

    {.name = "PMIX_COLLECTIVE_ALGO_REQD", .string = "pmix.calreqd", .type = PMIX_BOOL,
     .description = (char *[]){"***** DEPRECATED ***** if true, indicates that the",
                               "requested choice of algo is mandatory", NULL}},

    {.name = "PMIX_PROC_BLOB", .string = "pmix.pblob", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"***** DEPRECATED ***** packed blob of process data", NULL}},

    {.name = "PMIX_MAP_BLOB", .string = "pmix.mblob", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"***** DEPRECATED ***** packed blob of process",
                               "location", NULL}},

    {.name = "PMIX_MAPPER", .string = "pmix.mapper", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED ***** mapper to use for placing",
                               "spawned procs", NULL}},

    {.name = "PMIX_NON_PMI", .string = "pmix.nonpmi", .type = PMIX_BOOL,
     .description = (char *[]){"***** DEPRECATED ***** spawned procs will not call",
                               "PMIx_Init", NULL}},

    {.name = "PMIX_PROC_URI", .string = "pmix.puri", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED ***** URI containing contact info",
                               "for proc", NULL}},

    {.name = "PMIX_ARCH", .string = "pmix.arch", .type = PMIX_UINT32,
     .description = (char *[]){"***** DEPRECATED ***** datatype architecture flag", NULL}},

    {.name = "PMIX_DEBUG_JOB_DIRECTIVES", .string = "pmix.dbg.jdirs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"***** DEPRECATED ***** array of job-level directives", NULL}},

    {.name = "PMIX_DEBUG_APP_DIRECTIVES", .string = "pmix.dbg.adirs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"***** DEPRECATED ***** array of app-level directives", NULL}},

    {.name = "PMIX_EVENT_NO_TERMINATION", .string = "pmix.evnoterm", .type = PMIX_BOOL,
     .description = (char *[]){"***** DEPRECATED ***** indicates that the handler has",
                               "satisfactorily handled the event and believes",
                               "termination of the application is not required", NULL}},

    {.name = "PMIX_EVENT_WANT_TERMINATION", .string = "pmix.evterm", .type = PMIX_BOOL,
     .description = (char *[]){"***** DEPRECATED ***** indicates that the handler has",
                               "determined that the application should be terminated", NULL}},

    {.name = "PMIX_GDS_MODULE", .string = "pmix.gds.mod", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED ***** comma-delimited string of",
                               "desired modules", NULL}},

    {.name = "PMIX_IOF_STOP", .string = "pmix.iof.stop", .type = PMIX_BOOL,
     .description = (char *[]){"***** DEPRECATED ***** Stop forwarding the specified",
                               "channel(s)", NULL}},

    {.name = "PMIX_NOTIFY_LAUNCH", .string = "pmix.note.lnch", .type = PMIX_BOOL,
     .description = (char *[]){"***** DEPRECATED ***** notify the requestor upon",
                               "launch of the child job and return its namespace in",
                               "the event", NULL}},
    {.name = ""}

};
