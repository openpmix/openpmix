/*
 * This file is autogenerated by construct_dictionary.py.
 * Do not edit this file by hand.
 */

#include "src/include/pmix_config.h"
#include "src/include/pmix_globals.h"

pmix_regattr_input_t dictionary[] = {
    {.name = "PMIX_EVENT_BASE", .string = "pmix.evbase", .type = PMIX_POINTER,
     .description = (char *[]){"(struct event_base *) pointer to libevent event_base",
                               "to use in place of the internal progress thread", NULL}},

    {.name = "PMIX_SERVER_TOOL_SUPPORT", .string = "pmix.srvr.tool", .type = PMIX_BOOL,
     .description = (char *[]){"The host RM wants to declare itself as willing to",
                               "accept tool connection requests", NULL}},

    {.name = "PMIX_SERVER_REMOTE_CONNECTIONS", .string = "pmix.srvr.remote", .type = PMIX_BOOL,
     .description = (char *[]){"Allow connections from remote tools (do not use",
                               "loopback device)", NULL}},

    {.name = "PMIX_SERVER_SYSTEM_SUPPORT", .string = "pmix.srvr.sys", .type = PMIX_BOOL,
     .description = (char *[]){"The host RM wants to declare itself as being the",
                               "local system server for PMIx connection requests", NULL}},

    {.name = "PMIX_SERVER_SESSION_SUPPORT", .string = "pmix.srvr.sess", .type = PMIX_BOOL,
     .description = (char *[]){"The host RM wants to declare itself as being the",
                               "local session server for PMIx connection requests", NULL}},

    {.name = "PMIX_SERVER_TMPDIR", .string = "pmix.srvr.tmpdir", .type = PMIX_STRING,
     .description = (char *[]){"temp directory where PMIx server will place client",
                               "rendezvous points and contact info", NULL}},

    {.name = "PMIX_SYSTEM_TMPDIR", .string = "pmix.sys.tmpdir", .type = PMIX_STRING,
     .description = (char *[]){"temp directory for this system, where PMIx server",
                               "will place tool rendezvous points and contact info", NULL}},

    {.name = "PMIX_SERVER_ENABLE_MONITORING", .string = "pmix.srv.monitor", .type = PMIX_BOOL,
     .description = (char *[]){"Enable PMIx internal monitoring by server", NULL}},

    {.name = "PMIX_SERVER_NSPACE", .string = "pmix.srv.nspace", .type = PMIX_STRING,
     .description = (char *[]){"Name of the nspace to use for this server", NULL}},

    {.name = "PMIX_SERVER_RANK", .string = "pmix.srv.rank", .type = PMIX_PROC_RANK,
     .description = (char *[]){"Rank of this server", NULL}},

    {.name = "PMIX_SERVER_GATEWAY", .string = "pmix.srv.gway", .type = PMIX_BOOL,
     .description = (char *[]){"Server is acting as a gateway for PMIx requests that",
                               "cannot be serviced on backend nodes (e.g., logging to",
                               "email)", NULL}},

    {.name = "PMIX_SERVER_SCHEDULER", .string = "pmix.srv.sched", .type = PMIX_BOOL,
     .description = (char *[]){"Server supports system scheduler", NULL}},

    {.name = "PMIX_SERVER_START_TIME", .string = "pmix.srv.strtime", .type = PMIX_STRING,
     .description = (char *[]){"Time when the server started - i.e., when the server",
                               "created it's rendezvous file (given in ctime string",
                               "format)", NULL}},

    {.name = "PMIX_TOOL_NSPACE", .string = "pmix.tool.nspace", .type = PMIX_STRING,
     .description = (char *[]){"Name of the nspace to use for this tool", NULL}},

    {.name = "PMIX_TOOL_RANK", .string = "pmix.tool.rank", .type = PMIX_UINT32,
     .description = (char *[]){"Rank of this tool", NULL}},

    {.name = "PMIX_SERVER_PIDINFO", .string = "pmix.srvr.pidinfo", .type = PMIX_PID,
     .description = (char *[]){"pid of the target server for a tool", NULL}},

    {.name = "PMIX_CONNECT_TO_SYSTEM", .string = "pmix.cnct.sys", .type = PMIX_BOOL,
     .description = (char *[]){"The requestor requires that a connection be made only",
                               "to a local system-level PMIx server", NULL}},

    {.name = "PMIX_CONNECT_SYSTEM_FIRST", .string = "pmix.cnct.sys.first", .type = PMIX_BOOL,
     .description = (char *[]){"Preferentially look for a system-level PMIx server",
                               "first", NULL}},

    {.name = "PMIX_SERVER_URI", .string = "pmix.srvr.uri", .type = PMIX_STRING,
     .description = (char *[]){"URI of server to be contacted", NULL}},

    {.name = "PMIX_SERVER_HOSTNAME", .string = "pmix.srvr.host", .type = PMIX_STRING,
     .description = (char *[]){"node where target server is located", NULL}},

    {.name = "PMIX_CONNECT_MAX_RETRIES", .string = "pmix.tool.mretries", .type = PMIX_UINT32,
     .description = (char *[]){"maximum number of times to try to connect to server", NULL}},

    {.name = "PMIX_CONNECT_RETRY_DELAY", .string = "pmix.tool.retry", .type = PMIX_UINT32,
     .description = (char *[]){"time in seconds between connection attempts", NULL}},

    {.name = "PMIX_TOOL_DO_NOT_CONNECT", .string = "pmix.tool.nocon", .type = PMIX_BOOL,
     .description = (char *[]){"the tool wants to use internal PMIx support, but does",
                               "not want to connect to a PMIx server from the",
                               "specified processes to this tool", NULL}},

    {.name = "PMIX_TOOL_CONNECT_OPTIONAL", .string = "pmix.tool.conopt", .type = PMIX_BOOL,
     .description = (char *[]){"tool shall connect to a server if available, but",
                               "otherwise continue to operate unconnected", NULL}},

    {.name = "PMIX_RECONNECT_SERVER", .string = "pmix.cnct.recon", .type = PMIX_BOOL,
     .description = (char *[]){"tool is requesting to change server connections", NULL}},

    {.name = "PMIX_LAUNCHER", .string = "pmix.tool.launcher", .type = PMIX_BOOL,
     .description = (char *[]){"tool is a launcher and needs rendezvous files created", NULL}},

    {.name = "PMIX_LAUNCHER_RENDEZVOUS_FILE", .string = "pmix.tool.lncrnd", .type = PMIX_STRING,
     .description = (char *[]){"Pathname of file where connection info is to be",
                               "stored", NULL}},

    {.name = "PMIX_TOOL_ATTACHMENT_FILE", .string = "pmix.tool.attach", .type = PMIX_STRING,
     .description = (char *[]){"File containing connection info to be used for",
                               "attaching to server", NULL}},

    {.name = "PMIX_USERID", .string = "pmix.euid", .type = PMIX_UINT32,
     .description = (char *[]){"effective user id", NULL}},

    {.name = "PMIX_GRPID", .string = "pmix.egid", .type = PMIX_UINT32,
     .description = (char *[]){"effective group id", NULL}},

    {.name = "PMIX_DSTPATH", .string = "pmix.dstpath", .type = PMIX_STRING,
     .description = (char *[]){"path to dstore files", NULL}},

    {.name = "PMIX_VERSION_INFO", .string = "pmix.version", .type = PMIX_STRING,
     .description = (char *[]){"PMIx version of contactor", NULL}},

    {.name = "PMIX_REQUESTOR_IS_TOOL", .string = "pmix.req.tool", .type = PMIX_BOOL,
     .description = (char *[]){"requesting process is a tool", NULL}},

    {.name = "PMIX_REQUESTOR_IS_CLIENT", .string = "pmix.req.client", .type = PMIX_BOOL,
     .description = (char *[]){"requesting process is a client process", NULL}},

    {.name = "PMIX_PSET_NAME", .string = "pmix.pset.nm", .type = PMIX_STRING,
     .description = (char *[]){"user-assigned name for the process set containing the",
                               "given process", NULL}},

    {.name = "PMIX_REINCARNATION", .string = "pmix.reinc", .type = PMIX_UINT32,
     .description = (char *[]){"number of times this process has been instantiated -",
                               "i.e., tracks the number of times it has been",
                               "restarted", NULL}},

    {.name = "PMIX_PROGRAMMING_MODEL", .string = "pmix.pgm.model", .type = PMIX_STRING,
     .description = (char *[]){"programming model being initialized (e.g., \"MPI\" or",
                               "\"OpenMP\")", NULL}},

    {.name = "PMIX_MODEL_LIBRARY_NAME", .string = "pmix.mdl.name", .type = PMIX_STRING,
     .description = (char *[]){"programming model implementation ID (e.g.,",
                               "\"OpenMPI\" or \"MPICH\")", NULL}},

    {.name = "PMIX_MODEL_LIBRARY_VERSION", .string = "pmix.mld.vrs", .type = PMIX_STRING,
     .description = (char *[]){"programming model version string (e.g., \"2.1.1\")", NULL}},

    {.name = "PMIX_THREADING_MODEL", .string = "pmix.threads", .type = PMIX_STRING,
     .description = (char *[]){"threading model used (e.g., \"pthreads\")", NULL}},

    {.name = "PMIX_MODEL_NUM_THREADS", .string = "pmix.mdl.nthrds", .type = PMIX_UINT64,
     .description = (char *[]){"number of active threads being used by the model", NULL}},

    {.name = "PMIX_MODEL_NUM_CPUS", .string = "pmix.mdl.ncpu", .type = PMIX_UINT64,
     .description = (char *[]){"number of cpus being used by the model", NULL}},

    {.name = "PMIX_MODEL_CPU_TYPE", .string = "pmix.mdl.cputype", .type = PMIX_STRING,
     .description = (char *[]){"granularity - \"hwthread\", \"core\", etc.", NULL}},

    {.name = "PMIX_MODEL_PHASE_NAME", .string = "pmix.mdl.phase", .type = PMIX_STRING,
     .description = (char *[]){"user-assigned name for a phase in the application",
                               "execution - e.g., \"cfd reduction\"", NULL}},

    {.name = "PMIX_MODEL_PHASE_TYPE", .string = "pmix.mdl.ptype", .type = PMIX_STRING,
     .description = (char *[]){"type of phase being executed - e.g., \"matrix",
                               "multiply\"", NULL}},

    {.name = "PMIX_MODEL_AFFINITY_POLICY", .string = "pmix.mdl.tap", .type = PMIX_STRING,
     .description = (char *[]){"thread affinity policy - e.g.: \"master\" (thread",
                               "co-located with master thread), \"close\" (thread",
                               "located on cpu close to master thread) \"spread\"",
                               "(threads load-balanced across available cpus)", NULL}},

    {.name = "PMIX_USOCK_DISABLE", .string = "pmix.usock.disable", .type = PMIX_BOOL,
     .description = (char *[]){"disable legacy usock support", NULL}},

    {.name = "PMIX_SOCKET_MODE", .string = "pmix.sockmode", .type = PMIX_UINT32,
     .description = (char *[]){"POSIX mode_t (9 bits valid)", NULL}},

    {.name = "PMIX_SINGLE_LISTENER", .string = "pmix.sing.listnr", .type = PMIX_BOOL,
     .description = (char *[]){"use only one rendezvous socket, letting priorities",
                               "and/or MCA param select the active transport", NULL}},

    {.name = "PMIX_TCP_REPORT_URI", .string = "pmix.tcp.repuri", .type = PMIX_STRING,
     .description = (char *[]){"output URI - '-' => stdout, '+' => stderr, or",
                               "filename", NULL}},

    {.name = "PMIX_TCP_URI", .string = "pmix.tcp.uri", .type = PMIX_STRING,
     .description = (char *[]){"URI of server to connect to, or file:<name of file",
                               "containing it>", NULL}},

    {.name = "PMIX_TCP_IF_INCLUDE", .string = "pmix.tcp.ifinclude", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of devices and/or CIDR notation", NULL}},

    {.name = "PMIX_TCP_IF_EXCLUDE", .string = "pmix.tcp.ifexclude", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of devices and/or CIDR notation", NULL}},

    {.name = "PMIX_TCP_IPV4_PORT", .string = "pmix.tcp.ipv4", .type = PMIX_INT,
     .description = (char *[]){"IPv4 port to be used", NULL}},

    {.name = "PMIX_TCP_IPV6_PORT", .string = "pmix.tcp.ipv6", .type = PMIX_INT,
     .description = (char *[]){"IPv6 port to be used", NULL}},

    {.name = "PMIX_TCP_DISABLE_IPV4", .string = "pmix.tcp.disipv4", .type = PMIX_BOOL,
     .description = (char *[]){"true to disable IPv4 family", NULL}},

    {.name = "PMIX_TCP_DISABLE_IPV6", .string = "pmix.tcp.disipv6", .type = PMIX_BOOL,
     .description = (char *[]){"true to disable IPv6 family", NULL}},

    {.name = "PMIX_GDS_MODULE", .string = "pmix.gds.mod", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited string of desired modules", NULL}},

    {.name = "PMIX_CPUSET", .string = "pmix.cpuset", .type = PMIX_STRING,
     .description = (char *[]){"hwloc bitmap applied to proc upon launch", NULL}},

    {.name = "PMIX_CREDENTIAL", .string = "pmix.cred", .type = PMIX_STRING,
     .description = (char *[]){"security credential assigned to proc", NULL}},

    {.name = "PMIX_SPAWNED", .string = "pmix.spawned", .type = PMIX_BOOL,
     .description = (char *[]){"true if this proc resulted from a call to PMIx_Spawn", NULL}},

    {.name = "PMIX_ARCH", .string = "pmix.arch", .type = PMIX_UINT32,
     .description = (char *[]){"datatype architecture flag", NULL}},

    {.name = "PMIX_TMPDIR", .string = "pmix.tmpdir", .type = PMIX_STRING,
     .description = (char *[]){"top-level tmp dir assigned to session", NULL}},

    {.name = "PMIX_NSDIR", .string = "pmix.nsdir", .type = PMIX_STRING,
     .description = (char *[]){"sub-tmpdir assigned to namespace", NULL}},

    {.name = "PMIX_PROCDIR", .string = "pmix.pdir", .type = PMIX_STRING,
     .description = (char *[]){"sub-nsdir assigned to proc", NULL}},

    {.name = "PMIX_TDIR_RMCLEAN", .string = "pmix.tdir.rmclean", .type = PMIX_BOOL,
     .description = (char *[]){"Resource Manager will clean session directories", NULL}},

    {.name = "PMIX_CLUSTER_ID", .string = "pmix.clid", .type = PMIX_STRING,
     .description = (char *[]){"a string name for the cluster this proc is executing",
                               "on", NULL}},

    {.name = "PMIX_PROCID", .string = "pmix.procid", .type = PMIX_PROC,
     .description = (char *[]){"process identifier", NULL}},

    {.name = "PMIX_NSPACE", .string = "pmix.nspace", .type = PMIX_STRING,
     .description = (char *[]){"nspace of a job", NULL}},

    {.name = "PMIX_JOBID", .string = "pmix.jobid", .type = PMIX_STRING,
     .description = (char *[]){"jobid assigned by scheduler", NULL}},

    {.name = "PMIX_APPNUM", .string = "pmix.appnum", .type = PMIX_UINT32,
     .description = (char *[]){"app number within the job", NULL}},

    {.name = "PMIX_RANK", .string = "pmix.rank", .type = PMIX_PROC_RANK,
     .description = (char *[]){"process rank within the job", NULL}},

    {.name = "PMIX_GLOBAL_RANK", .string = "pmix.grank", .type = PMIX_PROC_RANK,
     .description = (char *[]){"rank spanning across all jobs in this session", NULL}},

    {.name = "PMIX_APP_RANK", .string = "pmix.apprank", .type = PMIX_PROC_RANK,
     .description = (char *[]){"rank within this app", NULL}},

    {.name = "PMIX_NPROC_OFFSET", .string = "pmix.offset", .type = PMIX_PROC_RANK,
     .description = (char *[]){"starting global rank of this job", NULL}},

    {.name = "PMIX_LOCAL_RANK", .string = "pmix.lrank", .type = PMIX_UINT16,
     .description = (char *[]){"rank on this node within this job", NULL}},

    {.name = "PMIX_NODE_RANK", .string = "pmix.nrank", .type = PMIX_UINT16,
     .description = (char *[]){"rank on this node spanning all jobs", NULL}},

    {.name = "PMIX_PACKAGE_RANK", .string = "pmix.pkgrank", .type = PMIX_UINT16,
     .description = (char *[]){"rank within this job on the package where this proc",
                               "resides", NULL}},

    {.name = "PMIX_LOCALLDR", .string = "pmix.lldr", .type = PMIX_PROC_RANK,
     .description = (char *[]){"lowest rank on this node within this job", NULL}},

    {.name = "PMIX_APPLDR", .string = "pmix.aldr", .type = PMIX_PROC_RANK,
     .description = (char *[]){"lowest rank in this app within this job", NULL}},

    {.name = "PMIX_PROC_PID", .string = "pmix.ppid", .type = PMIX_PID,
     .description = (char *[]){"pid of specified proc", NULL}},

    {.name = "PMIX_SESSION_ID", .string = "pmix.session.id", .type = PMIX_UINT32,
     .description = (char *[]){"session identifier", NULL}},

    {.name = "PMIX_NODE_LIST", .string = "pmix.nlist", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of nodes running procs for the",
                               "specified nspace", NULL}},

    {.name = "PMIX_ALLOCATED_NODELIST", .string = "pmix.alist", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of all nodes in this allocation",
                               "regardless of whether or not they currently host",
                               "procs.", NULL}},

    {.name = "PMIX_HOSTNAME", .string = "pmix.hname", .type = PMIX_STRING,
     .description = (char *[]){"name of the host the specified proc is on", NULL}},

    {.name = "PMIX_HOSTNAME_ALIASES", .string = "pmix.alias", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of names by which this node is",
                               "known", NULL}},

    {.name = "PMIX_HOSTNAME_KEEP_FQDN", .string = "pmix.fqdn", .type = PMIX_BOOL,
     .description = (char *[]){"FQDN hostnames are being retained", NULL}},

    {.name = "PMIX_NODEID", .string = "pmix.nodeid", .type = PMIX_UINT32,
     .description = (char *[]){"node identifier where the specified proc is located", NULL}},

    {.name = "PMIX_LOCAL_PEERS", .string = "pmix.lpeers", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited string of ranks on this node within",
                               "the specified nspace", NULL}},

    {.name = "PMIX_LOCAL_PROCS", .string = "pmix.lprocs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_proc_t of procs on the specified node", NULL}},

    {.name = "PMIX_LOCAL_CPUSETS", .string = "pmix.lcpus", .type = PMIX_STRING,
     .description = (char *[]){"colon-delimited cpusets of local peers within the",
                               "specified nspace", NULL}},

    {.name = "PMIX_PROC_URI", .string = "pmix.puri", .type = PMIX_STRING,
     .description = (char *[]){"URI containing contact info for proc", NULL}},

    {.name = "PMIX_LOCALITY", .string = "pmix.loc", .type = PMIX_UINT16,
     .description = (char *[]){"relative locality of two procs", NULL}},

    {.name = "PMIX_PARENT_ID", .string = "pmix.parent", .type = PMIX_PROC,
     .description = (char *[]){"identifier of the process that called PMIx_Spawn to",
                               "launch this proc's application", NULL}},

    {.name = "PMIX_EXIT_CODE", .string = "pmix.exit.code", .type = PMIX_INT,
     .description = (char *[]){"exit code returned when proc terminated", NULL}},

    {.name = "PMIX_UNIV_SIZE", .string = "pmix.univ.size", .type = PMIX_UINT32,
     .description = (char *[]){"#procs in this nspace", NULL}},

    {.name = "PMIX_JOB_SIZE", .string = "pmix.job.size", .type = PMIX_UINT32,
     .description = (char *[]){"#procs in this job", NULL}},

    {.name = "PMIX_JOB_NUM_APPS", .string = "pmix.job.napps", .type = PMIX_UINT32,
     .description = (char *[]){"#apps in this job", NULL}},

    {.name = "PMIX_APP_SIZE", .string = "pmix.app.size", .type = PMIX_UINT32,
     .description = (char *[]){"#procs in this application", NULL}},

    {.name = "PMIX_LOCAL_SIZE", .string = "pmix.local.size", .type = PMIX_UINT32,
     .description = (char *[]){"#procs in this job on this node", NULL}},

    {.name = "PMIX_NODE_SIZE", .string = "pmix.node.size", .type = PMIX_UINT32,
     .description = (char *[]){"#procs across all jobs on this node", NULL}},

    {.name = "PMIX_MAX_PROCS", .string = "pmix.max.size", .type = PMIX_UINT32,
     .description = (char *[]){"max #procs for this job", NULL}},

    {.name = "PMIX_NUM_SLOTS", .string = "pmix.num.slots", .type = PMIX_UINT32,
     .description = (char *[]){"#slots allocated", NULL}},

    {.name = "PMIX_NUM_NODES", .string = "pmix.num.nodes", .type = PMIX_UINT32,
     .description = (char *[]){"#nodes in this nspace", NULL}},

    {.name = "PMIX_AVAIL_PHYS_MEMORY", .string = "pmix.pmem", .type = PMIX_UINT64,
     .description = (char *[]){"total available physical memory on this node", NULL}},

    {.name = "PMIX_DAEMON_MEMORY", .string = "pmix.dmn.mem", .type = PMIX_FLOAT,
     .description = (char *[]){"Mbytes of memory currently used by daemon", NULL}},

    {.name = "PMIX_CLIENT_AVG_MEMORY", .string = "pmix.cl.mem.avg", .type = PMIX_FLOAT,
     .description = (char *[]){"Average Mbytes of memory used by client processes", NULL}},

    {.name = "PMIX_NET_TOPO", .string = "pmix.ntopo", .type = PMIX_STRING,
     .description = (char *[]){"xml-representation of fabric topology", NULL}},

    {.name = "PMIX_LOCAL_TOPO", .string = "pmix.ltopo", .type = PMIX_STRING,
     .description = (char *[]){"xml-representation of local node topology", NULL}},

    {.name = "PMIX_TOPOLOGY", .string = "pmix.topo", .type = PMIX_POINTER,
     .description = (char *[]){"pointer to the PMIx client's internal topology object", NULL}},

    {.name = "PMIX_TOPOLOGY_XML", .string = "pmix.topo.xml", .type = PMIX_STRING,
     .description = (char *[]){"XML-based description of topology", NULL}},

    {.name = "PMIX_TOPOLOGY_FILE", .string = "pmix.topo.file", .type = PMIX_STRING,
     .description = (char *[]){"full path to file containing XML topology description", NULL}},

    {.name = "PMIX_TOPOLOGY_SIGNATURE", .string = "pmix.toposig", .type = PMIX_STRING,
     .description = (char *[]){"topology signature string", NULL}},

    {.name = "PMIX_LOCALITY_STRING", .string = "pmix.locstr", .type = PMIX_STRING,
     .description = (char *[]){"string describing a proc's location", NULL}},

    {.name = "PMIX_HWLOC_SHMEM_ADDR", .string = "pmix.hwlocaddr", .type = PMIX_SIZE,
     .description = (char *[]){"address of HWLOC shared memory segment", NULL}},

    {.name = "PMIX_HWLOC_SHMEM_SIZE", .string = "pmix.hwlocsize", .type = PMIX_SIZE,
     .description = (char *[]){"size of HWLOC shared memory segment", NULL}},

    {.name = "PMIX_HWLOC_SHMEM_FILE", .string = "pmix.hwlocfile", .type = PMIX_STRING,
     .description = (char *[]){"path to HWLOC shared memory file", NULL}},

    {.name = "PMIX_HWLOC_XML_V1", .string = "pmix.hwlocxml1", .type = PMIX_STRING,
     .description = (char *[]){"XML representation of local topology using HWLOC v1.x",
                               "format", NULL}},

    {.name = "PMIX_HWLOC_XML_V2", .string = "pmix.hwlocxml2", .type = PMIX_STRING,
     .description = (char *[]){"XML representation of local topology using HWLOC v2.x",
                               "format", NULL}},

    {.name = "PMIX_HWLOC_SHARE_TOPO", .string = "pmix.hwlocsh", .type = PMIX_BOOL,
     .description = (char *[]){"Share the HWLOC topology via shared memory", NULL}},

    {.name = "PMIX_HWLOC_HOLE_KIND", .string = "pmix.hwlocholek", .type = PMIX_STRING,
     .description = (char *[]){"Kind of VM \"hole\" HWLOC should use for shared",
                               "memory", NULL}},

    {.name = "PMIX_COLLECT_DATA", .string = "pmix.collect", .type = PMIX_BOOL,
     .description = (char *[]){"collect data and return it at the end of the",
                               "operation", NULL}},

    {.name = "PMIX_TIMEOUT", .string = "pmix.timeout", .type = PMIX_INT,
     .description = (char *[]){"time in sec before specified operation should time",
                               "out (0 => infinite)", NULL}},

    {.name = "PMIX_IMMEDIATE", .string = "pmix.immediate", .type = PMIX_BOOL,
     .description = (char *[]){"specified operation should immediately return an",
                               "error from the PMIx server if requested data cannot",
                               "be found - do not request it from the host RM", NULL}},

    {.name = "PMIX_WAIT", .string = "pmix.wait", .type = PMIX_INT,
     .description = (char *[]){"caller requests that the server wait until at least",
                               "the specified #values are found (0 => all and is the",
                               "default)", NULL}},

    {.name = "PMIX_COLLECTIVE_ALGO", .string = "pmix.calgo", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of algorithms to use for",
                               "collective", NULL}},

    {.name = "PMIX_COLLECTIVE_ALGO_REQD", .string = "pmix.calreqd", .type = PMIX_BOOL,
     .description = (char *[]){"if true, indicates that the requested choice of algo",
                               "is mandatory", NULL}},

    {.name = "PMIX_NOTIFY_COMPLETION", .string = "pmix.notecomp", .type = PMIX_BOOL,
     .description = (char *[]){"notify parent process upon termination of child job", NULL}},

    {.name = "PMIX_RANGE", .string = "pmix.range", .type = PMIX_UINT8,
     .description = (char *[]){"value for calls to publish/lookup/unpublish or for",
                               "monitoring event notifications", NULL}},

    {.name = "PMIX_PERSISTENCE", .string = "pmix.persist", .type = PMIX_UINT8,
     .description = (char *[]){"value for calls to publish", NULL}},

    {.name = "PMIX_DATA_SCOPE", .string = "pmix.scope", .type = PMIX_UINT8,
     .description = (char *[]){"scope of the data to be found in a PMIx_Get call", NULL}},

    {.name = "PMIX_OPTIONAL", .string = "pmix.optional", .type = PMIX_BOOL,
     .description = (char *[]){"look only in the client's local data store for the",
                               "requested value - do not request data from the server",
                               "if not found", NULL}},

    {.name = "PMIX_EMBED_BARRIER", .string = "pmix.embed.barrier", .type = PMIX_BOOL,
     .description = (char *[]){"execute a blocking fence operation before executing",
                               "the specified operation", NULL}},

    {.name = "PMIX_JOB_TERM_STATUS", .string = "pmix.job.term.status", .type = PMIX_STATUS,
     .description = (char *[]){"status returned upon job termination", NULL}},

    {.name = "PMIX_PROC_TERM_STATUS", .string = "pmix.proc.term.status", .type = PMIX_STATUS,
     .description = (char *[]){"status returned upon process termination", NULL}},

    {.name = "PMIX_PROC_STATE_STATUS", .string = "pmix.proc.state", .type = PMIX_PROC_STATE,
     .description = (char *[]){"process state", NULL}},

    {.name = "PMIX_NOTIFY_LAUNCH", .string = "pmix.note.lnch", .type = PMIX_BOOL,
     .description = (char *[]){"notify the requestor upon launch of the child job and",
                               "return its namespace in the event", NULL}},

    {.name = "PMIX_GET_REFRESH_CACHE", .string = "pmix.get.refresh", .type = PMIX_BOOL,
     .description = (char *[]){"when retrieving data for a remote process, refresh",
                               "the existing local data cache for the process in case",
                               "new values have been put and committed by it since",
                               "the last refresh", NULL}},

    {.name = "PMIX_REGISTER_NODATA", .string = "pmix.reg.nodata", .type = PMIX_BOOL,
     .description = (char *[]){"Registration is for nspace only, do not copy job data", NULL}},

    {.name = "PMIX_PROC_DATA", .string = "pmix.pdata", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"starts with rank, then contains more data", NULL}},

    {.name = "PMIX_NODE_MAP", .string = "pmix.nmap", .type = PMIX_STRING,
     .description = (char *[]){"regex of nodes containing procs for this job", NULL}},

    {.name = "PMIX_PROC_MAP", .string = "pmix.pmap", .type = PMIX_STRING,
     .description = (char *[]){"regex describing procs on each node within this job", NULL}},

    {.name = "PMIX_ANL_MAP", .string = "pmix.anlmap", .type = PMIX_STRING,
     .description = (char *[]){"process mapping in ANL notation (used in PMI-1/PMI-2)", NULL}},

    {.name = "PMIX_APP_MAP_TYPE", .string = "pmix.apmap.type", .type = PMIX_STRING,
     .description = (char *[]){"type of mapping used to layout the application (e.g.,",
                               "cyclic)", NULL}},

    {.name = "PMIX_APP_MAP_REGEX", .string = "pmix.apmap.regex", .type = PMIX_STRING,
     .description = (char *[]){"regex describing the result of the mapping", NULL}},

    {.name = "PMIX_REQUIRED_KEY", .string = "pmix.req.key", .type = PMIX_STRING,
     .description = (char *[]){"key the user needs prior to responding from a dmodex",
                               "request", NULL}},

    {.name = "PMIX_PROC_BLOB", .string = "pmix.pblob", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"packed blob of process data", NULL}},

    {.name = "PMIX_MAP_BLOB", .string = "pmix.mblob", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"packed blob of process location", NULL}},

    {.name = "PMIX_EVENT_HDLR_NAME", .string = "pmix.evname", .type = PMIX_STRING,
     .description = (char *[]){"string name identifying this handler", NULL}},

    {.name = "PMIX_EVENT_HDLR_FIRST", .string = "pmix.evfirst", .type = PMIX_BOOL,
     .description = (char *[]){"invoke this event handler before any other handlers", NULL}},

    {.name = "PMIX_EVENT_HDLR_LAST", .string = "pmix.evlast", .type = PMIX_BOOL,
     .description = (char *[]){"invoke this event handler after all other handlers",
                               "have been called", NULL}},

    {.name = "PMIX_EVENT_HDLR_FIRST_IN_CATEGORY", .string = "pmix.evfirstcat", .type = PMIX_BOOL,
     .description = (char *[]){"invoke this event handler before any other handlers",
                               "in this category", NULL}},

    {.name = "PMIX_EVENT_HDLR_LAST_IN_CATEGORY", .string = "pmix.evlastcat", .type = PMIX_BOOL,
     .description = (char *[]){"invoke this event handler after all other handlers in",
                               "this category have been called", NULL}},

    {.name = "PMIX_EVENT_HDLR_BEFORE", .string = "pmix.evbefore", .type = PMIX_STRING,
     .description = (char *[]){"put this event handler immediately before the one",
                               "specified in the (char*) value", NULL}},

    {.name = "PMIX_EVENT_HDLR_AFTER", .string = "pmix.evafter", .type = PMIX_STRING,
     .description = (char *[]){"put this event handler immediately after the one",
                               "specified in the (char*) value", NULL}},

    {.name = "PMIX_EVENT_HDLR_PREPEND", .string = "pmix.evprepend", .type = PMIX_BOOL,
     .description = (char *[]){"prepend this handler to the precedence list within",
                               "its category", NULL}},

    {.name = "PMIX_EVENT_HDLR_APPEND", .string = "pmix.evappend", .type = PMIX_BOOL,
     .description = (char *[]){"append this handler to the precedence list within its",
                               "category", NULL}},

    {.name = "PMIX_EVENT_CUSTOM_RANGE", .string = "pmix.evrange", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_proc_t defining range of event",
                               "notification", NULL}},

    {.name = "PMIX_EVENT_AFFECTED_PROC", .string = "pmix.evproc", .type = PMIX_PROC,
     .description = (char *[]){"single proc that was affected", NULL}},

    {.name = "PMIX_EVENT_AFFECTED_PROCS", .string = "pmix.evaffected", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_proc_t defining affected procs", NULL}},

    {.name = "PMIX_EVENT_NON_DEFAULT", .string = "pmix.evnondef", .type = PMIX_BOOL,
     .description = (char *[]){"event is not to be delivered to default event",
                               "handlers", NULL}},

    {.name = "PMIX_EVENT_RETURN_OBJECT", .string = "pmix.evobject", .type = PMIX_POINTER,
     .description = (char *[]){"object to be returned whenever the registered cbfunc",
                               "is invoked NOTE: the object will _only_ be returned",
                               "to the process that registered it", NULL}},

    {.name = "PMIX_EVENT_DO_NOT_CACHE", .string = "pmix.evnocache", .type = PMIX_BOOL,
     .description = (char *[]){"instruct the PMIx server not to cache the event", NULL}},

    {.name = "PMIX_EVENT_SILENT_TERMINATION", .string = "pmix.evsilentterm", .type = PMIX_BOOL,
     .description = (char *[]){"do not generate an event when this job normally",
                               "terminates", NULL}},

    {.name = "PMIX_EVENT_PROXY", .string = "pmix.evproxy", .type = PMIX_PROC,
     .description = (char *[]){"PMIx server that sourced the event", NULL}},

    {.name = "PMIX_EVENT_TEXT_MESSAGE", .string = "pmix.evtext", .type = PMIX_STRING,
     .description = (char *[]){"text message suitable for output by recipient - e.g.,",
                               "describing the cause of the event", NULL}},

    {.name = "PMIX_EVENT_TERMINATE_SESSION", .string = "pmix.evterm.sess", .type = PMIX_BOOL,
     .description = (char *[]){"RM intends to terminate session", NULL}},

    {.name = "PMIX_EVENT_TERMINATE_JOB", .string = "pmix.evterm.job", .type = PMIX_BOOL,
     .description = (char *[]){"RM intends to terminate this job", NULL}},

    {.name = "PMIX_EVENT_TERMINATE_NODE", .string = "pmix.evterm.node", .type = PMIX_BOOL,
     .description = (char *[]){"RM intends to terminate all procs on this node", NULL}},

    {.name = "PMIX_EVENT_TERMINATE_PROC", .string = "pmix.evterm.proc", .type = PMIX_BOOL,
     .description = (char *[]){"RM intends to terminate just this process", NULL}},

    {.name = "PMIX_EVENT_ACTION_TIMEOUT", .string = "pmix.evtimeout", .type = PMIX_INT,
     .description = (char *[]){"time in sec before RM will execute error response", NULL}},

    {.name = "PMIX_EVENT_NO_TERMINATION", .string = "pmix.evnoterm", .type = PMIX_BOOL,
     .description = (char *[]){"indicates that the handler has satisfactorily handled",
                               "the event and believes termination of the application",
                               "is not required", NULL}},

    {.name = "PMIX_EVENT_WANT_TERMINATION", .string = "pmix.evterm", .type = PMIX_BOOL,
     .description = (char *[]){"indicates that the handler has determined that the",
                               "application should be terminated", NULL}},

    {.name = "PMIX_PERSONALITY", .string = "pmix.pers", .type = PMIX_STRING,
     .description = (char *[]){"name of personality to use", NULL}},

    {.name = "PMIX_HOST", .string = "pmix.host", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of hosts to use for spawned",
                               "procs", NULL}},

    {.name = "PMIX_HOSTFILE", .string = "pmix.hostfile", .type = PMIX_STRING,
     .description = (char *[]){"hostfile to use for spawned procs", NULL}},

    {.name = "PMIX_ADD_HOST", .string = "pmix.addhost", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of hosts to add to allocation", NULL}},

    {.name = "PMIX_ADD_HOSTFILE", .string = "pmix.addhostfile", .type = PMIX_STRING,
     .description = (char *[]){"hostfile to add to existing allocation", NULL}},

    {.name = "PMIX_PREFIX", .string = "pmix.prefix", .type = PMIX_STRING,
     .description = (char *[]){"prefix to use for starting spawned procs", NULL}},

    {.name = "PMIX_WDIR", .string = "pmix.wdir", .type = PMIX_STRING,
     .description = (char *[]){"working directory for spawned procs", NULL}},

    {.name = "PMIX_MAPPER", .string = "pmix.mapper", .type = PMIX_STRING,
     .description = (char *[]){"mapper to use for placing spawned procs", NULL}},

    {.name = "PMIX_DISPLAY_MAP", .string = "pmix.dispmap", .type = PMIX_BOOL,
     .description = (char *[]){"display process map upon spawn", NULL}},

    {.name = "PMIX_PPR", .string = "pmix.ppr", .type = PMIX_STRING,
     .description = (char *[]){"#procs to spawn on each identified resource", NULL}},

    {.name = "PMIX_MAPBY", .string = "pmix.mapby", .type = PMIX_STRING,
     .description = (char *[]){"mapping policy", NULL}},

    {.name = "PMIX_RANKBY", .string = "pmix.rankby", .type = PMIX_STRING,
     .description = (char *[]){"ranking policy", NULL}},

    {.name = "PMIX_BINDTO", .string = "pmix.bindto", .type = PMIX_STRING,
     .description = (char *[]){"binding policy", NULL}},

    {.name = "PMIX_PRELOAD_BIN", .string = "pmix.preloadbin", .type = PMIX_BOOL,
     .description = (char *[]){"preload binaries", NULL}},

    {.name = "PMIX_PRELOAD_FILES", .string = "pmix.preloadfiles", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of files to pre-position", NULL}},

    {.name = "PMIX_NON_PMI", .string = "pmix.nonpmi", .type = PMIX_BOOL,
     .description = (char *[]){"spawned procs will not call PMIx_Init", NULL}},

    {.name = "PMIX_STDIN_TGT", .string = "pmix.stdin", .type = PMIX_PROC,
     .description = (char *[]){"proc that is to receive stdin (PMIX_RANK_WILDCARD =",
                               "all in given nspace)", NULL}},

    {.name = "PMIX_DEBUGGER_DAEMONS", .string = "pmix.debugger", .type = PMIX_BOOL,
     .description = (char *[]){"spawned app consists of debugger daemons", NULL}},

    {.name = "PMIX_COSPAWN_APP", .string = "pmix.cospawn", .type = PMIX_BOOL,
     .description = (char *[]){"designated app is to be spawned as a disconnected job",
                               "- i.e., not part of the \"comm_world\" of the job", NULL}},

    {.name = "PMIX_SET_SESSION_CWD", .string = "pmix.ssncwd", .type = PMIX_BOOL,
     .description = (char *[]){"set the application's current working directory to",
                               "the session working directory assigned by the RM", NULL}},

    {.name = "PMIX_TAG_OUTPUT", .string = "pmix.tagout", .type = PMIX_BOOL,
     .description = (char *[]){"tag application output with the ID of the source", NULL}},

    {.name = "PMIX_TIMESTAMP_OUTPUT", .string = "pmix.tsout", .type = PMIX_BOOL,
     .description = (char *[]){"timestamp output from applications", NULL}},

    {.name = "PMIX_MERGE_STDERR_STDOUT", .string = "pmix.mergeerrout", .type = PMIX_BOOL,
     .description = (char *[]){"merge stdout and stderr streams from application",
                               "procs", NULL}},

    {.name = "PMIX_OUTPUT_TO_FILE", .string = "pmix.outfile", .type = PMIX_STRING,
     .description = (char *[]){"direct application output into files of form",
                               "\"<filename>.rank\" with both stdout and stderr",
                               "redirected into it", NULL}},

    {.name = "PMIX_OUTPUT_TO_DIRECTORY", .string = "pmix.outdir", .type = PMIX_STRING,
     .description = (char *[]){"direct application output into files of form",
                               "\"<directory>/<jobid>/rank.<rank>/stdout[err]\"", NULL}},

    {.name = "PMIX_INDEX_ARGV", .string = "pmix.indxargv", .type = PMIX_BOOL,
     .description = (char *[]){"mark the argv with the rank of the proc", NULL}},

    {.name = "PMIX_CPUS_PER_PROC", .string = "pmix.cpuperproc", .type = PMIX_UINT32,
     .description = (char *[]){"#cpus to assign to each rank", NULL}},

    {.name = "PMIX_NO_PROCS_ON_HEAD", .string = "pmix.nolocal", .type = PMIX_BOOL,
     .description = (char *[]){"do not place procs on the head node", NULL}},

    {.name = "PMIX_NO_OVERSUBSCRIBE", .string = "pmix.noover", .type = PMIX_BOOL,
     .description = (char *[]){"do not oversubscribe the cpus", NULL}},

    {.name = "PMIX_REPORT_BINDINGS", .string = "pmix.repbind", .type = PMIX_BOOL,
     .description = (char *[]){"report bindings of the individual procs", NULL}},

    {.name = "PMIX_CPU_LIST", .string = "pmix.cpulist", .type = PMIX_STRING,
     .description = (char *[]){"list of cpus to use for this job", NULL}},

    {.name = "PMIX_JOB_RECOVERABLE", .string = "pmix.recover", .type = PMIX_BOOL,
     .description = (char *[]){"application supports recoverable operations", NULL}},

    {.name = "PMIX_JOB_CONTINUOUS", .string = "pmix.continuous", .type = PMIX_BOOL,
     .description = (char *[]){"application is continuous, all failed procs should be",
                               "immediately restarted", NULL}},

    {.name = "PMIX_MAX_RESTARTS", .string = "pmix.maxrestarts", .type = PMIX_UINT32,
     .description = (char *[]){"max number of times to restart a job", NULL}},

    {.name = "PMIX_FWD_STDIN", .string = "pmix.fwd.stdin", .type = PMIX_BOOL,
     .description = (char *[]){"forward the stdin from this process to the target",
                               "processes", NULL}},

    {.name = "PMIX_FWD_STDOUT", .string = "pmix.fwd.stdout", .type = PMIX_BOOL,
     .description = (char *[]){"forward stdout from the spawned processes to this",
                               "process (typically used by a tool)", NULL}},

    {.name = "PMIX_FWD_STDERR", .string = "pmix.fwd.stderr", .type = PMIX_BOOL,
     .description = (char *[]){"forward stderr from the spawned processes to this",
                               "process (typically used by a tool)", NULL}},

    {.name = "PMIX_FWD_STDDIAG", .string = "pmix.fwd.stddiag", .type = PMIX_BOOL,
     .description = (char *[]){"if a diagnostic channel exists, forward any output on",
                               "it from the spawned processes to this process",
                               "(typically used by a tool)", NULL}},

    {.name = "PMIX_SPAWN_TOOL", .string = "pmix.spwn.tool", .type = PMIX_BOOL,
     .description = (char *[]){"job being spawned is a tool", NULL}},

    {.name = "PMIX_CMD_LINE", .string = "pmix.cmd.line", .type = PMIX_STRING,
     .description = (char *[]){"command line executing in the specified nspace", NULL}},

    {.name = "PMIX_FORK_EXEC_AGENT", .string = "pmix.fe.agnt", .type = PMIX_STRING,
     .description = (char *[]){"command line of fork/exec agent to be used for",
                               "starting local processes", NULL}},

    {.name = "PMIX_TIMEOUT_STACKTRACES", .string = "pmix.tim.stack", .type = PMIX_BOOL,
     .description = (char *[]){"include process stacktraces in timeout report from a",
                               "job", NULL}},

    {.name = "PMIX_TIMEOUT_REPORT_STATE", .string = "pmix.tim.state", .type = PMIX_BOOL,
     .description = (char *[]){"report process states in timeout report from a job", NULL}},

    {.name = "PMIX_APP_ARGV", .string = "pmix.app.argv", .type = PMIX_STRING,
     .description = (char *[]){"consolidated argv passed to the spawn command for the",
                               "given app", NULL}},

    {.name = "PMIX_QUERY_SUPPORTED_KEYS", .string = "pmix.qry.keys", .type = PMIX_STRING,
     .description = (char *[]){"returns comma-delimited list of keys supported by the",
                               "query function. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_NAMESPACES", .string = "pmix.qry.ns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of active namespaces.",
                               "NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_NAMESPACE_INFO", .string = "pmix.qry.nsinfo", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns an array of active nspace information - each",
                               "element will contain an array including the namespace",
                               "plus the command line of the application executing",
                               "within it SUPPORTED QUALIFIERS: PMIX_NSPACE of",
                               "specific nspace whose info is being requested", NULL}},

    {.name = "PMIX_QUERY_JOB_STATUS", .string = "pmix.qry.jst", .type = PMIX_STATUS,
     .description = (char *[]){"returns status of a specified currently executing job",
                               "REQUIRES a PMIX_NSPACE qualifier indicating the",
                               "nspace being queried", NULL}},

    {.name = "PMIX_QUERY_QUEUE_LIST", .string = "pmix.qry.qlst", .type = PMIX_STRING,
     .description = (char *[]){"request a comma-delimited list of scheduler queues.",
                               "NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_QUEUE_STATUS", .string = "pmix.qry.qst", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns array where each element contains the name",
                               "and status of a scheduler queue SUPPORTED QUALIFIERS:",
                               "PMIX_ALLOC_QUEUE naming specific queue whose status",
                               "is being requested", NULL}},

    {.name = "PMIX_QUERY_PROC_TABLE", .string = "pmix.qry.ptable", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns (pmix_data_array_t*) an array of",
                               "pmix_proc_info_t REQUIRES a PMIX_NSPACE qualifier",
                               "indicating the nspace being queried", NULL}},

    {.name = "PMIX_QUERY_LOCAL_PROC_TABLE", .string = "pmix.qry.lptable", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns (pmix_data_array_t*) an array of",
                               "pmix_proc_info_t of pmix_proc_info_t for procs in job",
                               "on same node REQUIRES a PMIX_NSPACE qualifier",
                               "indicating the nspace being queried", NULL}},

    {.name = "PMIX_QUERY_AUTHORIZATIONS", .string = "pmix.qry.auths", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"return operations tool is authorized to perform. The",
                               "contents of the array elements have not yet been",
                               "standardized. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_SPAWN_SUPPORT", .string = "pmix.qry.spawn", .type = PMIX_STRING,
     .description = (char *[]){"return a comma-delimited list of supported spawn",
                               "attributes. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_DEBUG_SUPPORT", .string = "pmix.qry.debug", .type = PMIX_STRING,
     .description = (char *[]){"return a comma-delimited list of supported debug",
                               "attributes. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_MEMORY_USAGE", .string = "pmix.qry.mem", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"return info on memory usage for the procs indicated",
                               "in the qualifiers SUPPORTED QUALIFIERS:",
                               "PMIX_NSPACE/PMIX_RANK, or PMIX_PROCID of specific",
                               "proc(s) whose info is being requested", NULL}},

    {.name = "PMIX_QUERY_ALLOC_STATUS", .string = "pmix.query.alloc", .type = PMIX_STRING,
     .description = (char *[]){"return a string reporting status of an allocation",
                               "request REQUIRES a PMIX_ALLOC_ID qualifier indicating",
                               "the allocation request being queried", NULL}},

    {.name = "PMIX_TIME_REMAINING", .string = "pmix.time.remaining", .type = PMIX_UINT32,
     .description = (char *[]){"returns number of seconds remaining in allocation for",
                               "the specified nspace (defaults to allocation",
                               "containing the caller) SUPPORTED QUALIFIERS:",
                               "PMIX_NSPACE of the nspace whose info is being",
                               "requested", NULL}},

    {.name = "PMIX_QUERY_NUM_PSETS", .string = "pmix.qry.psetnum", .type = PMIX_SIZE,
     .description = (char *[]){"returns the number of psets defined in the specified",
                               "range (defaults to session) SUPPORTED QUALIFIERS:",
                               "PMIX_RANGE whose info is being requested", NULL}},

    {.name = "PMIX_QUERY_PSET_NAMES", .string = "pmix.qry.psets", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of the names of the",
                               "psets defined in the specified range (defaults to",
                               "session) SUPPORTED QUALIFIERS: PMIX_RANGE whose info",
                               "is being requested", NULL}},

    {.name = "PMIX_QUERY_ATTRIBUTE_SUPPORT", .string = "pmix.qry.attrs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"returns array of pmix_info_t where each element",
                               "consists of a key containing the name of the",
                               "function, and an array of pmix_regattr_t detailing",
                               "the attribute support for that function SUPPORTED",
                               "QUALIFIERS: PMIX_CLIENT_FUNCTIONS,",
                               "PMIX_SERVER_FUNCTIONS, PMIX_TOOL_FUNCTIONS, and/or",
                               "PMIX_HOST_FUNCTIONS", NULL}},

    {.name = "PMIX_CLIENT_FUNCTIONS", .string = "pmix.client.fns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of supported PMIx",
                               "client functions. NO QUALIFIERS", NULL}},

    {.name = "PMIX_SERVER_FUNCTIONS", .string = "pmix.srvr.fns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of supported PMIx",
                               "server functions. NO QUALIFIERS", NULL}},

    {.name = "PMIX_TOOL_FUNCTIONS", .string = "pmix.tool.fns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of supported PMIx tool",
                               "functions. NO QUALIFIERS", NULL}},

    {.name = "PMIX_HOST_FUNCTIONS", .string = "pmix.host.fns", .type = PMIX_STRING,
     .description = (char *[]){"returns a comma-delimited list of PMIx functions",
                               "supported by the host environment", NULL}},

    {.name = "PMIX_QUERY_AVAIL_SERVERS", .string = "pmix.qry.asrvrs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_info_t, each element containing an",
                               "array of pmix_info_t of available data for servers on",
                               "this node to which the caller might be able to",
                               "connect. NO QUALIFIERS", NULL}},

    {.name = "PMIX_QUERY_REFRESH_CACHE", .string = "pmix.qry.rfsh", .type = PMIX_BOOL,
     .description = (char *[]){"retrieve updated information from server to update",
                               "local cache", NULL}},

    {.name = "PMIX_QUERY_LOCAL_ONLY", .string = "pmix.qry.local", .type = PMIX_BOOL,
     .description = (char *[]){"constrain the query to local information only", NULL}},

    {.name = "PMIX_QUERY_REPORT_AVG", .string = "pmix.qry.avg", .type = PMIX_BOOL,
     .description = (char *[]){"report average values", NULL}},

    {.name = "PMIX_QUERY_REPORT_MINMAX", .string = "pmix.qry.minmax", .type = PMIX_BOOL,
     .description = (char *[]){"report minimum and maximum value", NULL}},

    {.name = "PMIX_CLIENT_ATTRIBUTES", .string = "pmix.client.attrs", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of functions, including \"all\"",
                               "when used in a query, indicates whether or not to",
                               "include attributes supported by the PMIx client",
                               "library", NULL}},

    {.name = "PMIX_SERVER_ATTRIBUTES", .string = "pmix.srvr.attrs", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of functions, including \"all\"",
                               "when used in a query, indicates whether or not to",
                               "include attributes supported by the PMIx server",
                               "library", NULL}},

    {.name = "PMIX_HOST_ATTRIBUTES", .string = "pmix.host.attrs", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of functions, including \"all\"",
                               "when used in a query, indicates whether or not to",
                               "include attributes supported by the host environment", NULL}},

    {.name = "PMIX_TOOL_ATTRIBUTES", .string = "pmix.tool.attrs", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of functions, including \"all\"",
                               "when used in a query, indicates whether or not to",
                               "include attributes supported by the PMIx tool library", NULL}},

    {.name = "PMIX_QUERY_SUPPORTED_QUALIFIERS", .string = "pmix.qry.quals", .type = PMIX_BOOL,
     .description = (char *[]){"return comma-delimited list of qualifiers supported",
                               "by a query on the provided key, instead of actually",
                               "performing the query on the key.", NULL}},

    {.name = "PMIX_SESSION_INFO", .string = "pmix.ssn.info", .type = PMIX_BOOL,
     .description = (char *[]){"Return information about the specified session. If",
                               "information about a session other than the one",
                               "containing the requesting process is desired, then",
                               "the attribute array must contain a PMIX_SESSION_ID",
                               "attribute identifying the desired target.", NULL}},

    {.name = "PMIX_JOB_INFO", .string = "pmix.job.info", .type = PMIX_BOOL,
     .description = (char *[]){"Return information about the specified job or",
                               "namespace. If information about a job or namespace",
                               "other than the one containing the requesting process",
                               "is desired, then the attribute array must contain a",
                               "PMIX_JOBID or PMIX_NSPACE attribute identifying the",
                               "desired target. Similarly, if information is",
                               "requested about a job or namespace in a session other",
                               "than the one containing the requesting process, then",
                               "an attribute identifying the target session must be",
                               "provided.", NULL}},

    {.name = "PMIX_APP_INFO", .string = "pmix.app.info", .type = PMIX_BOOL,
     .description = (char *[]){"Return information about the specified application.",
                               "If information about an application other than the",
                               "one containing the requesting process is desired,",
                               "then the attribute array must contain a PMIX_APPNUM",
                               "attribute identifying the desired target. Similarly,",
                               "if information is requested about an application in a",
                               "job or session other than the one containing the",
                               "requesting process, then attributes identifying the",
                               "target job and/or session must be provided.", NULL}},

    {.name = "PMIX_NODE_INFO", .string = "pmix.node.info", .type = PMIX_BOOL,
     .description = (char *[]){"Return information about the specified node. If",
                               "information about a node other than the one",
                               "containing the requesting process is desired, then",
                               "the attribute array must contain either the",
                               "PMIX_NODEID or PMIX_HOSTNAME attribute identifying",
                               "the desired target.", NULL}},

    {.name = "PMIX_SESSION_INFO_ARRAY", .string = "pmix.ssn.arr", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Provide an array of pmix_info_t containing",
                               "session-level information. The PMIX_SESSION_ID",
                               "attribute is required to be included in the array.", NULL}},

    {.name = "PMIX_JOB_INFO_ARRAY", .string = "pmix.job.arr", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Provide an array of pmix_info_t containing job-level",
                               "information. Information is registered one job (aka",
                               "namespace) at a time via the",
                               "PMIx_server_register_nspace API. Thus, there is no",
                               "requirement that the array contain either the",
                               "PMIX_NSPACE or PMIX_JOBID attributes, though either",
                               "or both of them may be included.", NULL}},

    {.name = "PMIX_APP_INFO_ARRAY", .string = "pmix.app.arr", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Provide an array of pmix_info_t containing app-level",
                               "information. The PMIX_NSPACE or PMIX_JOBID attributes",
                               "of the job containing the appplication, plus its",
                               "PMIX_APPNUM attribute, are required to be included in",
                               "the array.", NULL}},

    {.name = "PMIX_NODE_INFO_ARRAY", .string = "pmix.node.arr", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Provide an array of pmix_info_t containing node-level",
                               "information. At a minimum, either the PMIX_NODEID or",
                               "PMIX_HOSTNAME attribute is required to be included in",
                               "the array, though both may be included.", NULL}},

    {.name = "PMIX_SERVER_INFO_ARRAY", .string = "pmix.srv.info", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of data on a given server, starting with its",
                               "nspace", NULL}},

    {.name = "PMIX_LOG_SOURCE", .string = "pmix.log.source", .type = PMIX_PROC,
     .description = (char *[]){"ID of source of the log request", NULL}},

    {.name = "PMIX_LOG_STDERR", .string = "pmix.log.stderr", .type = PMIX_STRING,
     .description = (char *[]){"log string to stderr", NULL}},

    {.name = "PMIX_LOG_STDOUT", .string = "pmix.log.stdout", .type = PMIX_STRING,
     .description = (char *[]){"log string to stdout", NULL}},

    {.name = "PMIX_LOG_SYSLOG", .string = "pmix.log.syslog", .type = PMIX_STRING,
     .description = (char *[]){"log message to syslog - defaults to ERROR priority.",
                               "Will log to global syslog if available, otherwise to",
                               "local syslog", NULL}},

    {.name = "PMIX_LOG_LOCAL_SYSLOG", .string = "pmix.log.lsys", .type = PMIX_STRING,
     .description = (char *[]){"log msg to local syslog - defaults to ERROR priority", NULL}},

    {.name = "PMIX_LOG_GLOBAL_SYSLOG", .string = "pmix.log.gsys", .type = PMIX_STRING,
     .description = (char *[]){"forward data to system \"master\" and log msg to that",
                               "syslog", NULL}},

    {.name = "PMIX_LOG_SYSLOG_PRI", .string = "pmix.log.syspri", .type = PMIX_INT,
     .description = (char *[]){"syslog priority level", NULL}},

    {.name = "PMIX_LOG_TIMESTAMP", .string = "pmix.log.tstmp", .type = PMIX_TIME,
     .description = (char *[]){"timestamp for log report", NULL}},

    {.name = "PMIX_LOG_GENERATE_TIMESTAMP", .string = "pmix.log.gtstmp", .type = PMIX_BOOL,
     .description = (char *[]){"generate timestamp for log", NULL}},

    {.name = "PMIX_LOG_TAG_OUTPUT", .string = "pmix.log.tag", .type = PMIX_BOOL,
     .description = (char *[]){"label the output stream with the channel name (e.g.,",
                               "\"stdout\")", NULL}},

    {.name = "PMIX_LOG_TIMESTAMP_OUTPUT", .string = "pmix.log.tsout", .type = PMIX_BOOL,
     .description = (char *[]){"print timestamp in output string", NULL}},

    {.name = "PMIX_LOG_XML_OUTPUT", .string = "pmix.log.xml", .type = PMIX_BOOL,
     .description = (char *[]){"print the output stream in xml format", NULL}},

    {.name = "PMIX_LOG_ONCE", .string = "pmix.log.once", .type = PMIX_BOOL,
     .description = (char *[]){"only log this once with whichever channel can first",
                               "support it", NULL}},

    {.name = "PMIX_LOG_MSG", .string = "pmix.log.msg", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"message blob to be sent somewhere", NULL}},

    {.name = "PMIX_LOG_EMAIL", .string = "pmix.log.email", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"log via email based on array of pmix_info_t",
                               "containing directives", NULL}},

    {.name = "PMIX_LOG_EMAIL_ADDR", .string = "pmix.log.emaddr", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of email addresses that are to",
                               "recv msg", NULL}},

    {.name = "PMIX_LOG_EMAIL_SENDER_ADDR", .string = "pmix.log.emfaddr", .type = PMIX_STRING,
     .description = (char *[]){"return email address of sender", NULL}},

    {.name = "PMIX_LOG_EMAIL_SUBJECT", .string = "pmix.log.emsub", .type = PMIX_STRING,
     .description = (char *[]){"subject line for email", NULL}},

    {.name = "PMIX_LOG_EMAIL_MSG", .string = "pmix.log.emmsg", .type = PMIX_STRING,
     .description = (char *[]){"msg to be included in email", NULL}},

    {.name = "PMIX_LOG_EMAIL_SERVER", .string = "pmix.log.esrvr", .type = PMIX_STRING,
     .description = (char *[]){"hostname (or IP addr) of estmp server", NULL}},

    {.name = "PMIX_LOG_EMAIL_SRVR_PORT", .string = "pmix.log.esrvrprt", .type = PMIX_INT32,
     .description = (char *[]){"port the email server is listening to", NULL}},

    {.name = "PMIX_LOG_GLOBAL_DATASTORE", .string = "pmix.log.gstore", .type = PMIX_BOOL,
     .description = (char *[]){"log the provided data to a global datastore", NULL}},

    {.name = "PMIX_LOG_JOB_RECORD", .string = "pmix.log.jrec", .type = PMIX_BOOL,
     .description = (char *[]){"log the provided information to the RM's job record", NULL}},

    {.name = "PMIX_DEBUG_STOP_ON_EXEC", .string = "pmix.dbg.exec", .type = PMIX_BOOL,
     .description = (char *[]){"job is being spawned under debugger - instruct it to",
                               "pause on start", NULL}},

    {.name = "PMIX_DEBUG_STOP_IN_INIT", .string = "pmix.dbg.init", .type = PMIX_BOOL,
     .description = (char *[]){"instruct job to stop during PMIx init", NULL}},

    {.name = "PMIX_DEBUG_WAIT_FOR_NOTIFY", .string = "pmix.dbg.notify", .type = PMIX_BOOL,
     .description = (char *[]){"block at desired point until receiving debugger",
                               "release notification", NULL}},

    {.name = "PMIX_DEBUG_JOB", .string = "pmix.dbg.job", .type = PMIX_STRING,
     .description = (char *[]){"nspace of the job assigned to this debugger to be",
                               "debugged. Note that id's, pids, and other info on the",
                               "procs is available via a query for the nspace's local",
                               "or global proctable", NULL}},

    {.name = "PMIX_DEBUG_WAITING_FOR_NOTIFY", .string = "pmix.dbg.waiting", .type = PMIX_BOOL,
     .description = (char *[]){"job to be debugged is waiting for a release", NULL}},

    {.name = "PMIX_DEBUG_JOB_DIRECTIVES", .string = "pmix.dbg.jdirs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of job-level directives", NULL}},

    {.name = "PMIX_DEBUG_APP_DIRECTIVES", .string = "pmix.dbg.adirs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of app-level directives", NULL}},

    {.name = "PMIX_DEBUG_TARGET", .string = "pmix.dbg.tgt", .type = PMIX_PROC,
     .description = (char *[]){"Identifier of proc(s) to be debugged", NULL}},

    {.name = "PMIX_RM_NAME", .string = "pmix.rm.name", .type = PMIX_STRING,
     .description = (char *[]){"string name of the resource manager", NULL}},

    {.name = "PMIX_RM_VERSION", .string = "pmix.rm.version", .type = PMIX_STRING,
     .description = (char *[]){"RM version string", NULL}},

    {.name = "PMIX_SET_ENVAR", .string = "pmix.envar.set", .type = PMIX_ENVAR,
     .description = (char *[]){"set the envar to the given value, overwriting any",
                               "pre-existing one", NULL}},

    {.name = "PMIX_ADD_ENVAR", .string = "pmix.envar.add", .type = PMIX_ENVAR,
     .description = (char *[]){"add envar, but do not overwrite any existing one", NULL}},

    {.name = "PMIX_UNSET_ENVAR", .string = "pmix.envar.unset", .type = PMIX_STRING,
     .description = (char *[]){"unset the envar, if present", NULL}},

    {.name = "PMIX_PREPEND_ENVAR", .string = "pmix.envar.prepnd", .type = PMIX_ENVAR,
     .description = (char *[]){"prepend the given value to the specified envar using",
                               "the separator character, creating the envar if it",
                               "doesn't already exist", NULL}},

    {.name = "PMIX_APPEND_ENVAR", .string = "pmix.envar.appnd", .type = PMIX_ENVAR,
     .description = (char *[]){"append the given value to the specified envar using",
                               "the separator character, creating the envar if it",
                               "doesn't already exist", NULL}},

    {.name = "PMIX_FIRST_ENVAR", .string = "pmix.envar.first", .type = PMIX_ENVAR,
     .description = (char *[]){"ensure the given value appears first in the specified",
                               "envar using the separator character, creating the",
                               "envar if it doesn't already exist", NULL}},

    {.name = "PMIX_ALLOC_ID", .string = "pmix.alloc.id", .type = PMIX_STRING,
     .description = (char *[]){"provide a string identifier for this allocation",
                               "request which can later be used to query status of",
                               "the request", NULL}},

    {.name = "PMIX_ALLOC_NUM_NODES", .string = "pmix.alloc.nnodes", .type = PMIX_UINT64,
     .description = (char *[]){"number of nodes", NULL}},

    {.name = "PMIX_ALLOC_NODE_LIST", .string = "pmix.alloc.nlist", .type = PMIX_STRING,
     .description = (char *[]){"regex of specific nodes", NULL}},

    {.name = "PMIX_ALLOC_NUM_CPUS", .string = "pmix.alloc.ncpus", .type = PMIX_UINT64,
     .description = (char *[]){"number of cpus", NULL}},

    {.name = "PMIX_ALLOC_NUM_CPU_LIST", .string = "pmix.alloc.ncpulist", .type = PMIX_STRING,
     .description = (char *[]){"regex of #cpus for each node", NULL}},

    {.name = "PMIX_ALLOC_CPU_LIST", .string = "pmix.alloc.cpulist", .type = PMIX_STRING,
     .description = (char *[]){"regex of specific cpus indicating the cpus involved.", NULL}},

    {.name = "PMIX_ALLOC_MEM_SIZE", .string = "pmix.alloc.msize", .type = PMIX_FLOAT,
     .description = (char *[]){"number of Mbytes", NULL}},

    {.name = "PMIX_ALLOC_NETWORK", .string = "pmix.alloc.net", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_FABRIC", .string = "pmix.alloc.net", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"Array of pmix_info_t describing fabric resource",
                               "request. This must include at least: *",
                               "PMIX_ALLOC_FABRIC_ID * PMIX_ALLOC_FABRIC_TYPE *",
                               "PMIX_ALLOC_FABRIC_ENDPTS plus whatever other",
                               "descriptors are desired", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_ID", .string = "pmix.alloc.netid", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_ID", .string = "pmix.alloc.netid", .type = PMIX_STRING,
     .description = (char *[]){"key to be used when accessing this requested fabric",
                               "allocation. The allocation will be returned/stored as",
                               "a pmix_data_array_t of pmix_info_t indexed by this",
                               "key and containing at least one entry with the same",
                               "key and the allocated resource description. The type",
                               "of the included value depends upon the fabric",
                               "support. For example, a TCP allocation might consist",
                               "of a comma-delimited string of socket ranges such as",
                               "\"32000-32100,33005,38123-38146\". Additional entries",
                               "will consist of any provided resource request",
                               "directives, along with their assigned values.",
                               "Examples include: * PMIX_ALLOC_FABRIC_TYPE - the type",
                               "of resources provided * PMIX_ALLOC_FABRIC_PLANE - if",
                               "applicable, what plane the resources were assigned",
                               "from * PMIX_ALLOC_FABRIC_QOS - the assigned QoS *",
                               "PMIX_ALLOC_BANDWIDTH - the allocated bandwidth *",
                               "PMIX_ALLOC_FABRIC_SEC_KEY - a security key for the",
                               "requested fabric allocation NOTE: the assigned values",
                               "may differ from those requested, especially if the",
                               "\"required\" flag was not set in the request", NULL}},

    {.name = "PMIX_ALLOC_BANDWIDTH", .string = "pmix.alloc.bw", .type = PMIX_FLOAT,
     .description = (char *[]){"Mbits/sec", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_QOS", .string = "pmix.alloc.netqos", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_QOS", .string = "pmix.alloc.netqos", .type = PMIX_STRING,
     .description = (char *[]){"quality of service level", NULL}},

    {.name = "PMIX_ALLOC_TIME", .string = "pmix.alloc.time", .type = PMIX_UINT32,
     .description = (char *[]){"time in seconds that the allocation shall remain",
                               "valid", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_TYPE", .string = "pmix.alloc.nettype", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_TYPE", .string = "pmix.alloc.nettype", .type = PMIX_STRING,
     .description = (char *[]){"type of desired transport (e.g., tcp, udp)", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_PLANE", .string = "pmix.alloc.netplane", .type = PMIX_STRING,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_PLANE", .string = "pmix.alloc.netplane", .type = PMIX_STRING,
     .description = (char *[]){"id string for the NIC (aka plane) to be used for this",
                               "allocation (e.g., CIDR for Ethernet)", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_ENDPTS", .string = "pmix.alloc.endpts", .type = PMIX_SIZE,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_ENDPTS", .string = "pmix.alloc.endpts", .type = PMIX_SIZE,
     .description = (char *[]){"number of endpoints to allocate per process", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_ENDPTS_NODE", .string = "pmix.alloc.endpts.nd", .type = PMIX_SIZE,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_ENDPTS_NODE", .string = "pmix.alloc.endpts.nd", .type = PMIX_SIZE,
     .description = (char *[]){"number of endpoints to allocate per node", NULL}},

    {.name = "PMIX_ALLOC_NETWORK_SEC_KEY", .string = "pmix.alloc.nsec", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"***** DEPRECATED *****", NULL}},

    {.name = "PMIX_ALLOC_FABRIC_SEC_KEY", .string = "pmix.alloc.nsec", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"fabric security key", NULL}},

    {.name = "PMIX_ALLOC_QUEUE", .string = "pmix.alloc.queue", .type = PMIX_STRING,
     .description = (char *[]){"name of queue being referenced", NULL}},

    {.name = "PMIX_JOB_CTRL_ID", .string = "pmix.jctrl.id", .type = PMIX_STRING,
     .description = (char *[]){"provide a string identifier for this request", NULL}},

    {.name = "PMIX_JOB_CTRL_PAUSE", .string = "pmix.jctrl.pause", .type = PMIX_BOOL,
     .description = (char *[]){"pause the specified processes", NULL}},

    {.name = "PMIX_JOB_CTRL_RESUME", .string = "pmix.jctrl.resume", .type = PMIX_BOOL,
     .description = (char *[]){"\"un-pause\" the specified processes", NULL}},

    {.name = "PMIX_JOB_CTRL_CANCEL", .string = "pmix.jctrl.cancel", .type = PMIX_STRING,
     .description = (char *[]){"cancel the specified request (NULL => cancel all",
                               "requests from this requestor)", NULL}},

    {.name = "PMIX_JOB_CTRL_KILL", .string = "pmix.jctrl.kill", .type = PMIX_BOOL,
     .description = (char *[]){"forcibly terminate the specified processes and",
                               "cleanup", NULL}},

    {.name = "PMIX_JOB_CTRL_RESTART", .string = "pmix.jctrl.restart", .type = PMIX_STRING,
     .description = (char *[]){"restart the specified processes using the given",
                               "checkpoint ID", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT", .string = "pmix.jctrl.ckpt", .type = PMIX_STRING,
     .description = (char *[]){"checkpoint the specified processes and assign the",
                               "given ID to it", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT_EVENT", .string = "pmix.jctrl.ckptev", .type = PMIX_BOOL,
     .description = (char *[]){"use event notification to trigger process checkpoint", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT_SIGNAL", .string = "pmix.jctrl.ckptsig", .type = PMIX_INT,
     .description = (char *[]){"use the given signal to trigger process checkpoint", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT_TIMEOUT", .string = "pmix.jctrl.ckptsig", .type = PMIX_INT,
     .description = (char *[]){"time in seconds to wait for checkpoint to complete", NULL}},

    {.name = "PMIX_JOB_CTRL_CHECKPOINT_METHOD", .string = "pmix.jctrl.ckmethod", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of pmix_info_t declaring each method and value",
                               "supported by this application", NULL}},

    {.name = "PMIX_JOB_CTRL_SIGNAL", .string = "pmix.jctrl.sig", .type = PMIX_INT,
     .description = (char *[]){"send given signal to specified processes", NULL}},

    {.name = "PMIX_JOB_CTRL_PROVISION", .string = "pmix.jctrl.pvn", .type = PMIX_STRING,
     .description = (char *[]){"regex identifying nodes that are to be provisioned", NULL}},

    {.name = "PMIX_JOB_CTRL_PROVISION_IMAGE", .string = "pmix.jctrl.pvnimg", .type = PMIX_STRING,
     .description = (char *[]){"name of the image that is to be provisioned", NULL}},

    {.name = "PMIX_JOB_CTRL_PREEMPTIBLE", .string = "pmix.jctrl.preempt", .type = PMIX_BOOL,
     .description = (char *[]){"job can be pre-empted", NULL}},

    {.name = "PMIX_JOB_CTRL_TERMINATE", .string = "pmix.jctrl.term", .type = PMIX_BOOL,
     .description = (char *[]){"politely terminate the specified procs", NULL}},

    {.name = "PMIX_REGISTER_CLEANUP", .string = "pmix.reg.cleanup", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of files to be removed upon",
                               "process termination", NULL}},

    {.name = "PMIX_REGISTER_CLEANUP_DIR", .string = "pmix.reg.cleanupdir", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of directories to be removed",
                               "upon process termination", NULL}},

    {.name = "PMIX_CLEANUP_RECURSIVE", .string = "pmix.clnup.recurse", .type = PMIX_BOOL,
     .description = (char *[]){"recursively cleanup all subdirectories under the",
                               "specified one(s)", NULL}},

    {.name = "PMIX_CLEANUP_EMPTY", .string = "pmix.clnup.empty", .type = PMIX_BOOL,
     .description = (char *[]){"only remove empty subdirectories", NULL}},

    {.name = "PMIX_CLEANUP_IGNORE", .string = "pmix.clnup.ignore", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited list of filenames that are not to be",
                               "removed", NULL}},

    {.name = "PMIX_CLEANUP_LEAVE_TOPDIR", .string = "pmix.clnup.lvtop", .type = PMIX_BOOL,
     .description = (char *[]){"when recursively cleaning subdirs, do not remove the",
                               "top-level directory (the one given in the cleanup",
                               "request)", NULL}},

    {.name = "PMIX_MONITOR_ID", .string = "pmix.monitor.id", .type = PMIX_STRING,
     .description = (char *[]){"provide a string identifier for this request", NULL}},

    {.name = "PMIX_MONITOR_CANCEL", .string = "pmix.monitor.cancel", .type = PMIX_STRING,
     .description = (char *[]){"identifier to be canceled (NULL = cancel all",
                               "monitoring for this process)", NULL}},

    {.name = "PMIX_MONITOR_APP_CONTROL", .string = "pmix.monitor.appctrl", .type = PMIX_BOOL,
     .description = (char *[]){"the application desires to control the response to a",
                               "monitoring event", NULL}},

    {.name = "PMIX_MONITOR_HEARTBEAT", .string = "pmix.monitor.mbeat", .type = PMIX_BOOL,
     .description = (char *[]){"register to have the server monitor the requestor for",
                               "heartbeats", NULL}},

    {.name = "PMIX_SEND_HEARTBEAT", .string = "pmix.monitor.beat", .type = PMIX_BOOL,
     .description = (char *[]){"send heartbeat to local server", NULL}},

    {.name = "PMIX_MONITOR_HEARTBEAT_TIME", .string = "pmix.monitor.btime", .type = PMIX_UINT32,
     .description = (char *[]){"time in seconds before declaring heartbeat missed", NULL}},

    {.name = "PMIX_MONITOR_HEARTBEAT_DROPS", .string = "pmix.monitor.bdrop", .type = PMIX_UINT32,
     .description = (char *[]){"number of heartbeats that can be missed before",
                               "generating the event", NULL}},

    {.name = "PMIX_MONITOR_FILE", .string = "pmix.monitor.fmon", .type = PMIX_STRING,
     .description = (char *[]){"register to monitor file for signs of life", NULL}},

    {.name = "PMIX_MONITOR_FILE_SIZE", .string = "pmix.monitor.fsize", .type = PMIX_BOOL,
     .description = (char *[]){"monitor size of given file is growing to determine",
                               "app is running", NULL}},

    {.name = "PMIX_MONITOR_FILE_ACCESS", .string = "pmix.monitor.faccess", .type = PMIX_STRING,
     .description = (char *[]){"monitor time since last access of given file to",
                               "determine app is running", NULL}},

    {.name = "PMIX_MONITOR_FILE_MODIFY", .string = "pmix.monitor.fmod", .type = PMIX_STRING,
     .description = (char *[]){"monitor time since last modified of given file to",
                               "determine app is running", NULL}},

    {.name = "PMIX_MONITOR_FILE_CHECK_TIME", .string = "pmix.monitor.ftime", .type = PMIX_UINT32,
     .description = (char *[]){"time in seconds between checking file", NULL}},

    {.name = "PMIX_MONITOR_FILE_DROPS", .string = "pmix.monitor.fdrop", .type = PMIX_UINT32,
     .description = (char *[]){"number of file checks that can be missed before",
                               "generating the event", NULL}},

    {.name = "PMIX_CRED_TYPE", .string = "pmix.sec.ctype", .type = PMIX_STRING,
     .description = (char *[]){"when passed in PMIx_Get_credential, a prioritized,",
                               "comma-delimited list of desired credential types for",
                               "use in environments where multiple authentication",
                               "mechanisms may be available. When returned in a",
                               "callback function, a string identifier of the",
                               "credential type", NULL}},

    {.name = "PMIX_CRYPTO_KEY", .string = "pmix.sec.key", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"blob containing crypto key", NULL}},

    {.name = "PMIX_IOF_CACHE_SIZE", .string = "pmix.iof.csize", .type = PMIX_UINT32,
     .description = (char *[]){"requested size of the server cache in bytes for each",
                               "specified channel. By default, the server is allowed",
                               "(but not required) to drop all bytes received beyond",
                               "the max size", NULL}},

    {.name = "PMIX_IOF_DROP_OLDEST", .string = "pmix.iof.old", .type = PMIX_BOOL,
     .description = (char *[]){"in an overflow situation, drop the oldest bytes to",
                               "make room in the cache", NULL}},

    {.name = "PMIX_IOF_DROP_NEWEST", .string = "pmix.iof.new", .type = PMIX_BOOL,
     .description = (char *[]){"in an overflow situation, drop any new bytes received",
                               "until room becomes available in the cache (default)", NULL}},

    {.name = "PMIX_IOF_BUFFERING_SIZE", .string = "pmix.iof.bsize", .type = PMIX_UINT32,
     .description = (char *[]){"basically controls grouping of IO on the specified",
                               "channel(s) to avoid being called every time a bit of",
                               "IO arrives. The library will execute the callback",
                               "whenever the specified number of bytes becomes",
                               "available. Any remaining buffered data will be",
                               "\"flushed\" upon call to deregister the respective",
                               "channel", NULL}},

    {.name = "PMIX_IOF_BUFFERING_TIME", .string = "pmix.iof.btime", .type = PMIX_UINT32,
     .description = (char *[]){"max time in seconds to buffer IO before delivering",
                               "it. Used in conjunction with buffering size, this",
                               "prevents IO from being held indefinitely while",
                               "waiting for another payload to arrive", NULL}},

    {.name = "PMIX_IOF_COMPLETE", .string = "pmix.iof.cmp", .type = PMIX_BOOL,
     .description = (char *[]){"indicates whether or not the specified IO channel has",
                               "been closed by the source", NULL}},

    {.name = "PMIX_IOF_PUSH_STDIN", .string = "pmix.iof.stdin", .type = PMIX_BOOL,
     .description = (char *[]){"Used by a tool to request that the PMIx library",
                               "collect the tool's stdin and forward it to the procs",
                               "specified in the PMIx_IOF_push call", NULL}},

    {.name = "PMIX_IOF_TAG_OUTPUT", .string = "pmix.iof.tag", .type = PMIX_BOOL,
     .description = (char *[]){"Tag output with the channel it comes from", NULL}},

    {.name = "PMIX_IOF_TIMESTAMP_OUTPUT", .string = "pmix.iof.ts", .type = PMIX_BOOL,
     .description = (char *[]){"Timestamp output", NULL}},

    {.name = "PMIX_IOF_XML_OUTPUT", .string = "pmix.iof.xml", .type = PMIX_BOOL,
     .description = (char *[]){"Format output in XML", NULL}},

    {.name = "PMIX_IOF_STOP", .string = "pmix.iof.stop", .type = PMIX_BOOL,
     .description = (char *[]){"Stop forwarding the specified channel(s)", NULL}},

    {.name = "PMIX_SETUP_APP_ENVARS", .string = "pmix.setup.env", .type = PMIX_BOOL,
     .description = (char *[]){"harvest and include relevant envars", NULL}},

    {.name = "PMIX_SETUP_APP_NONENVARS", .string = "pmix.setup.nenv", .type = PMIX_BOOL,
     .description = (char *[]){"include all non-envar data", NULL}},

    {.name = "PMIX_SETUP_APP_ALL", .string = "pmix.setup.all", .type = PMIX_BOOL,
     .description = (char *[]){"include all relevant data", NULL}},

    {.name = "PMIX_GROUP_ID", .string = "pmix.grp.id", .type = PMIX_STRING,
     .description = (char *[]){"user-provided group identifier", NULL}},

    {.name = "PMIX_GROUP_LEADER", .string = "pmix.grp.ldr", .type = PMIX_BOOL,
     .description = (char *[]){"this process is the leader of the group", NULL}},

    {.name = "PMIX_GROUP_OPTIONAL", .string = "pmix.grp.opt", .type = PMIX_BOOL,
     .description = (char *[]){"participation is optional - do not return an error if",
                               "any of the specified processes terminate without",
                               "having joined. The default is false", NULL}},

    {.name = "PMIX_GROUP_NOTIFY_TERMINATION", .string = "pmix.grp.notterm", .type = PMIX_BOOL,
     .description = (char *[]){"notify remaining members when another member",
                               "terminates without first leaving the group. The",
                               "default is false", NULL}},

    {.name = "PMIX_GROUP_INVITE_DECLINE", .string = "pmix.grp.decline", .type = PMIX_BOOL,
     .description = (char *[]){"notify the inviting process that this process does",
                               "not wish to participate in the proposed group The",
                               "default is true", NULL}},

    {.name = "PMIX_GROUP_FT_COLLECTIVE", .string = "pmix.grp.ftcoll", .type = PMIX_BOOL,
     .description = (char *[]){"adjust internal tracking for terminated processes.",
                               "Default is false", NULL}},

    {.name = "PMIX_GROUP_MEMBERSHIP", .string = "pmix.grp.mbrs", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of group member ID's", NULL}},

    {.name = "PMIX_GROUP_ASSIGN_CONTEXT_ID", .string = "pmix.grp.actxid", .type = PMIX_BOOL,
     .description = (char *[]){"request that the RM assign a unique numerical",
                               "(size_t) ID to this group", NULL}},

    {.name = "PMIX_GROUP_CONTEXT_ID", .string = "pmix.grp.ctxid", .type = PMIX_SIZE,
     .description = (char *[]){"context ID assigned to group", NULL}},

    {.name = "PMIX_GROUP_LOCAL_ONLY", .string = "pmix.grp.lcl", .type = PMIX_BOOL,
     .description = (char *[]){"group operation only involves local procs", NULL}},

    {.name = "PMIX_GROUP_ENDPT_DATA", .string = "pmix.grp.endpt", .type = PMIX_BYTE_OBJECT,
     .description = (char *[]){"data collected to be shared during construction", NULL}},

    {.name = "PMIX_QUERY_STORAGE_LIST", .string = "pmix.strg.list", .type = PMIX_STRING,
     .description = (char *[]){"return comma-delimited list of identifiers for all",
                               "available storage systems", NULL}},

    {.name = "PMIX_STORAGE_CAPACITY_LIMIT", .string = "pmix.strg.cap", .type = PMIX_UINT64,
     .description = (char *[]){"return overall capacity (in Megabytes[base2]) of",
                               "specified storage system", NULL}},

    {.name = "PMIX_STORAGE_CAPACITY_FREE", .string = "pmix.strg.free", .type = PMIX_UINT64,
     .description = (char *[]){"return free capacity (in Megabytes[base2]) of",
                               "specified storage system", NULL}},

    {.name = "PMIX_STORAGE_CAPACITY_AVAIL", .string = "pmix.strg.avail", .type = PMIX_UINT64,
     .description = (char *[]){"return capacity (in Megabytes[[base2]]) of specified",
                               "storage system that is available for use by the",
                               "calling program", NULL}},

    {.name = "PMIX_STORAGE_OBJECT_LIMIT", .string = "pmix.strg.obj", .type = PMIX_UINT64,
     .description = (char *[]){"return overall limit on number of objects (e.g.,",
                               "inodes) of specified storage system", NULL}},

    {.name = "PMIX_STORAGE_OBJECTS_FREE", .string = "pmix.strg.objf", .type = PMIX_UINT64,
     .description = (char *[]){"return number of free objects (e.g., inodes) of",
                               "specified storage system", NULL}},

    {.name = "PMIX_STORAGE_OBJECTS_AVAIL", .string = "pmix.strg.obja", .type = PMIX_UINT64,
     .description = (char *[]){"return number of objects (e.g., inodes) of specified",
                               "storage system that are available for use by the",
                               "calling program", NULL}},

    {.name = "PMIX_STORAGE_BW", .string = "pmix.strg.bw", .type = PMIX_FLOAT,
     .description = (char *[]){"return overall bandwidth (in Megabytes[base2]/sec) of",
                               "specified storage system", NULL}},

    {.name = "PMIX_STORAGE_AVAIL_BW", .string = "pmix.strg.availbw", .type = PMIX_FLOAT,
     .description = (char *[]){"return overall bandwidth (in Megabytes[base2]/sec) of",
                               "specified storage system that is available for use by",
                               "the calling program", NULL}},

    {.name = "PMIX_STORAGE_ID", .string = "pmix.strg.id", .type = PMIX_STRING,
     .description = (char *[]){"identifier of the storage system being referenced", NULL}},

    {.name = "PMIX_STORAGE_PATH", .string = "pmix.strg.path", .type = PMIX_STRING,
     .description = (char *[]){"Mount point corresponding to a specified storage ID", NULL}},

    {.name = "PMIX_STORAGE_TYPE", .string = "pmix.strg.type", .type = PMIX_STRING,
     .description = (char *[]){"Qualifier indicating the type of storage being",
                               "referenced by a query (e.g., lustre, gpfs, online,",
                               "fabric-attached, ...)", NULL}},

    {.name = "PMIX_FABRIC_COST_MATRIX", .string = "pmix.fab.cm", .type = PMIX_POINTER,
     .description = (char *[]){"Pointer to a two-dimensional array of point-to-point",
                               "relative communication costs expressed as uint16_t",
                               "values", NULL}},

    {.name = "PMIX_FABRIC_GROUPS", .string = "pmix.fab.grps", .type = PMIX_STRING,
     .description = (char *[]){"A string delineating the group membership of nodes in",
                               "the system, where each fabric group consists of the",
                               "group number followed by a colon and a",
                               "comma-delimited list of nodes in that group, with the",
                               "groups delimited by semi-colons (e.g.,",
                               "0:node000,node002,node004,node006;1:node001,node003,node005,node007)", NULL}},

    {.name = "PMIX_FABRIC_VENDOR", .string = "pmix.fab.vndr", .type = PMIX_STRING,
     .description = (char *[]){"Name of fabric vendor (e.g., Amazon, Mellanox, Cray,",
                               "Intel)", NULL}},

    {.name = "PMIX_FABRIC_IDENTIFIER", .string = "pmix.fab.id", .type = PMIX_STRING,
     .description = (char *[]){"An identifier for the fabric (e.g., MgmtEthernet,",
                               "Slingshot-11, OmniPath-1)", NULL}},

    {.name = "PMIX_FABRIC_NUM_VERTICES", .string = "pmix.fab.nverts", .type = PMIX_SIZE,
     .description = (char *[]){"Total number of NICs in the system - corresponds to",
                               "the number of vertices (i.e., rows and columns) in",
                               "the cost matrix", NULL}},

    {.name = "PMIX_FABRIC_COORDINATE", .string = "pmix.net.coord", .type = PMIX_COORD,
     .description = (char *[]){"Fabric coordinate of the specified process in the",
                               "given view type (e.g., logical vs physical)", NULL}},

    {.name = "PMIX_FABRIC_VIEW", .string = "pmix.net.view", .type = PMIX_UINT8,
     .description = (char *[]){"Requested view type (e.g., logical vs physical)", NULL}},

    {.name = "PMIX_FABRIC_DIMS", .string = "pmix.net.dims", .type = PMIX_UINT32,
     .description = (char *[]){"Number of dimensions in the specified fabric",
                               "plane/view", NULL}},

    {.name = "PMIX_FABRIC_PLANE", .string = "pmix.net.plane", .type = PMIX_STRING,
     .description = (char *[]){"string ID of a fabric plane", NULL}},

    {.name = "PMIX_FABRIC_SWITCH", .string = "pmix.net.switch", .type = PMIX_STRING,
     .description = (char *[]){"string ID of a fabric switch", NULL}},

    {.name = "PMIX_FABRIC_NIC", .string = "pmix.net.nic", .type = PMIX_STRING,
     .description = (char *[]){"string ID of a NIC", NULL}},

    {.name = "PMIX_FABRIC_ENDPT", .string = "pmix.net.endpt", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"array of fabric endpts for process", NULL}},

    {.name = "PMIX_FABRIC_SHAPE", .string = "pmix.net.shape", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"number of interfaces (uint32_t) on each dimension of",
                               "the specified fabric plane in the requested view", NULL}},

    {.name = "PMIX_FABRIC_SHAPE_STRING", .string = "pmix.net.shapestr", .type = PMIX_STRING,
     .description = (char *[]){"fabric shape expressed as a string (e.g.,",
                               "\"10x12x2\")", NULL}},

    {.name = "PMIX_SWITCH_PEERS", .string = "pmix.speers", .type = PMIX_STRING,
     .description = (char *[]){"comma-delimited string of peers that share the same",
                               "switch as the proc specified in the call to PMIx_Get.",
                               "Multi-NIC environments will return an array of",
                               "results, each element containing the NIC and the list",
                               "of peers sharing the switch to which that NIC is",
                               "connected.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE", .string = "pmix.fabdev", .type = PMIX_DATA_ARRAY,
     .description = (char *[]){"An array of pmix_info_t describing a particular",
                               "fabric device (NIC).", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_NAME", .string = "pmix.fabdev.nm", .type = PMIX_STRING,
     .description = (char *[]){"The operating system name associated with the device.",
                               "This may be a logical fabric interface name (e.g.",
                               "eth0 or eno1) or an absolute filename.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_VENDOR", .string = "pmix.fabdev.vndr", .type = PMIX_STRING,
     .description = (char *[]){"Indicates the name of the vendor that distributes the",
                               "NIC.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_BUS_TYPE", .string = "pmix.fabdev.btyp", .type = PMIX_STRING,
     .description = (char *[]){"The type of bus to which the device is attached",
                               "(e.g., \"PCI\", \"GEN-Z\").", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_ID", .string = "pmix.fabdev.devid", .type = PMIX_STRING,
     .description = (char *[]){"A vendor-provided identifier for the device or",
                               "product", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_DRIVER", .string = "pmix.fabdev.driver", .type = PMIX_STRING,
     .description = (char *[]){"The name of the driver associated with the device", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_FIRMWARE", .string = "pmix.fabdev.fmwr", .type = PMIX_STRING,
     .description = (char *[]){"The devices firmware version", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_ADDRESS", .string = "pmix.fabdev.addr", .type = PMIX_STRING,
     .description = (char *[]){"The primary link-level address associated with the",
                               "NIC, such as a MAC address. If multiple addresses are",
                               "available, only one will be reported.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_MTU", .string = "pmix.fabdev.mtu", .type = PMIX_SIZE,
     .description = (char *[]){"The maximum transfer unit of link level frames or",
                               "packets, in bytes.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_SPEED", .string = "pmix.fabdev.speed", .type = PMIX_SIZE,
     .description = (char *[]){"The active link data rate, given in bits per second.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_STATE", .string = "pmix.fabdev.state", .type = PMIX_LINK_STATE,
     .description = (char *[]){"The last available physical port state. Possible",
                               "values are PMIX_LINK_STATE_UNKNOWN, PMIX_LINK_DOWN,",
                               "and PMIX_LINK_UP, to indicate if the port state is",
                               "unknown or not applicable (unknown), inactive (down),",
                               "or active (up).", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_TYPE", .string = "pmix.fabdev.type", .type = PMIX_STRING,
     .description = (char *[]){"Specifies the type of fabric interface currently",
                               "active on the device, such as Ethernet or InfiniBand.", NULL}},

    {.name = "PMIX_FABRIC_DEVICE_PCI_DEVID", .string = "pmix.fabdev.pcidevid", .type = PMIX_STRING,
     .description = (char *[]){"A node-level unique identifier for a PCI device.",
                               "Provided only if the device is located on a \ac{PCI}",
                               "bus. The identifier is constructed as a four-part",
                               "tuple delimited by colons comprised of the \ac{PCI}",
                               "16-bit domain, 8-bit bus, 8-bit device, and 8-bit",
                               "function IDs, each expressed in zero-extended",
                               "hexadecimal form. Thus, an example identifier might",
                               "be \"abc1:0f:23:01\". The combination of node",
                               "identifier PMIX_HOSTNAME or PMIX_NODEID and",
                               "PMIX_FABRIC_DEVICE_PCI_DEVID shall be unique within",
                               "the system.", NULL}},
    {.name = ""}

};
